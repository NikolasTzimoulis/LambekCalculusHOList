theorems {
	fingerprint: 2021047437507260674  
	conclusion: "(a (c (fun (fun (recspace (num)) (bool)) (bool)) ?) (l (v (recspace (num)) a) (a (c (fun (fun (fun (recspace (num)) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (num)) (bool)) string') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (fun (recspace (num)) (bool)) (bool)) !) (l (v (recspace (num)) a) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (fun (num) (bool)) (bool)) ?) (l (v (num) a) (a (a (c (fun (recspace (num)) (fun (recspace (num)) (bool))) =) (v (recspace (num)) a)) (a (l (v (num) a) (a (a (a (c (fun (num) (fun (num) (fun (fun (num) (recspace (num))) (recspace (num))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (v (num) a)) (l (v (num) n) (c (recspace (num)) BOTTOM)))) (v (num) a)))))) (a (v (fun (recspace (num)) (bool)) string') (v (recspace (num)) a)))))) (a (v (fun (recspace (num)) (bool)) string') (v (recspace (num)) a)))))))"
	tag: THEOREM
	training_split: TRAINING
    library_tag: "c-fDL.ml"
	pretty_printed: "|- ?a. !string'. (!a. (?a. a = (\\a. CONSTR 0 a (\\n. BOTTOM)) a) ==> string' a) ==> string' a"
	proof_function: "type_definition_helper"
}

theorems {
	pretty_printed: "|- (!a. _mk_string (_dest_string a) = a) /\\ (!r. (!string'. (!a. (?a. a = (\\a. CONSTR 0 a (\\n. BOTTOM)) a)        ==> string' a)   ==> string' r) <=>   _dest_string (_mk_string r) = r)"
	fingerprint: 1306460808711712470  
	conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (string) (bool)) (bool)) !) (l (v (string) a) (a (a (c (fun (string) (fun (string) (bool))) =) (a (c (fun (recspace (num)) (string)) _mk_string) (a (c (fun (string) (recspace (num))) _dest_string) (v (string) a)))) (v (string) a))))) (a (c (fun (fun (recspace (num)) (bool)) (bool)) !) (l (v (recspace (num)) r) (a (a (c (fun (bool) (fun (bool) (bool))) =) (a (c (fun (fun (fun (recspace (num)) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (num)) (bool)) string') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (fun (recspace (num)) (bool)) (bool)) !) (l (v (recspace (num)) a) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (fun (num) (bool)) (bool)) ?) (l (v (num) a) (a (a (c (fun (recspace (num)) (fun (recspace (num)) (bool))) =) (v (recspace (num)) a)) (a (l (v (num) a) (a (a (a (c (fun (num) (fun (num) (fun (fun (num) (recspace (num))) (recspace (num))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (v (num) a)) (l (v (num) n) (c (recspace (num)) BOTTOM)))) (v (num) a)))))) (a (v (fun (recspace (num)) (bool)) string') (v (recspace (num)) a)))))) (a (v (fun (recspace (num)) (bool)) string') (v (recspace (num)) r)))))) (a (a (c (fun (recspace (num)) (fun (recspace (num)) (bool))) =) (a (c (fun (string) (recspace (num))) _dest_string) (a (c (fun (recspace (num)) (string)) _mk_string) (v (recspace (num)) r)))) (v (recspace (num)) r))))))"
	tag: TYPE_DEFINITION
	type_definition {
		type_name: "string"
		abs_name: "_mk_string"
		rep_name: "_dest_string"
		theorem_arg: 2021047437507260674 
	}
    library_tag: "c-fDL.ml"
} 

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) form') (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) pform') (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) nform') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a0') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a0')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a)))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a0')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a))))))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0')))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a1') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) a) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a)))))))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a1')))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a2) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) a) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a))))))))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a2)))))))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a)))))))))))" 
	tag: THEOREM 
	training_split: TRAINING
    library_tag: "c-fDL.ml"
	pretty_printed: "|- ?a. !form' pform' nform'.      (!a0'. (?a. a0' = (\\a. CONSTR 0 (@v. T) (FCONS a (\\n. BOTTOM))) a /\\      pform' a) \\/ (?a. a0' =      (\\a. CONSTR (SUC 0) (@v. T) (FCONS a (\\n. BOTTOM))) a /\\      nform' a) ==> form' a0') /\\      (!a1'. (?a. a1' = (\\a. CONSTR (SUC (SUC 0)) a (\\n. BOTTOM)) a) \\/ (?a0 a1.      a1' =      (\\a0 a1.           CONSTR (SUC (SUC (SUC 0))) (@v. T)           (FCONS a0 (FCONS a1 (\\n. BOTTOM))))      a0      a1 /\\      form' a0 /\\      form' a1) \\/ (?a. a1' =      (\\a. CONSTR (SUC (SUC (SUC (SUC 0)))) (@v. T)           (FCONS a (\\n. BOTTOM)))      a /\\      form' a) ==> pform' a1') /\\      (!a2. (?a. a2 =     (\\a. CONSTR (SUC (SUC (SUC (SUC (SUC 0))))) a          (\\n. BOTTOM))     a) \\/      (?a0 a1.     a2 =     (\\a0 a1.          CONSTR (SUC (SUC (SUC (SUC (SUC (SUC 0))))))          (@v. T)          (FCONS a0 (FCONS a1 (\\n. BOTTOM))))     a0     a1 /\\     form' a0 /\\     form' a1) \\/      (?a0 a1.     a2 =     (\\a0 a1.          CONSTR (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0)))))))          (@v. T)          (FCONS a0 (FCONS a1 (\\n. BOTTOM))))     a0     a1 /\\     form' a0 /\\     form' a1) \\/      (?a. a2 =     (\\a. CONSTR          (SUC (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))))          (@v. T)          (FCONS a (\\n. BOTTOM)))     a /\\     form' a)      ==> nform' a2)      ==> form' a" 
	proof_function: "type_definition_helper"
} 
theorems { 
	pretty_printed: "|- (!a. _mk_form (_dest_form a) = a) /\\ (!r. (!form' pform' nform'.  (!a0'. (?a. a0' =        (\\a. CONSTR 0 (@v. T) (FCONS a (\\n. BOTTOM))) a /\\        pform' a) \\/   (?a. a0' =        (\\a. CONSTR (SUC 0) (@v. T) (FCONS a (\\n. BOTTOM)))        a /\\        nform' a)   ==> form' a0') /\\  (!a1'. (?a. a1' = (\\a. CONSTR (SUC (SUC 0)) a (\\n. BOTTOM)) a) \\/   (?a0 a1.        a1' =        (\\a0 a1.             CONSTR (SUC (SUC (SUC 0))) (@v. T)             (FCONS a0 (FCONS a1 (\\n. BOTTOM))))        a0        a1 /\\        form' a0 /\\        form' a1) \\/   (?a. a1' =        (\\a. CONSTR (SUC (SUC (SUC (SUC 0)))) (@v. T)             (FCONS a (\\n. BOTTOM)))        a /\\        form' a)   ==> pform' a1') /\\  (!a2. (?a. a2 =       (\\a. CONSTR (SUC (SUC (SUC (SUC (SUC 0))))) a            (\\n. BOTTOM))       a) \\/  (?a0 a1.       a2 =       (\\a0 a1.            CONSTR (SUC (SUC (SUC (SUC (SUC (SUC 0))))))            (@v. T)            (FCONS a0 (FCONS a1 (\\n. BOTTOM))))       a0       a1 /\\       form' a0 /\\       form' a1) \\/  (?a0 a1.       a2 =       (\\a0 a1.            CONSTR            (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0)))))))            (@v. T)            (FCONS a0 (FCONS a1 (\\n. BOTTOM))))       a0       a1 /\\       form' a0 /\\       form' a1) \\/  (?a. a2 =       (\\a. CONSTR            (SUC            (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))))            (@v. T)            (FCONS a (\\n. BOTTOM)))       a /\\       form' a)  ==> nform' a2)  ==> form' r) <=>   _dest_form (_mk_form r) = r)" 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (a (c (fun (form) (fun (form) (bool))) =) (a (c (fun (recspace (list (char))) (form)) _mk_form) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a)))) (v (form) a))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) r) (a (a (c (fun (bool) (fun (bool) (bool))) =) (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) form') (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) pform') (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) nform') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a0') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a0')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a)))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a0')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a))))))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0')))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a1') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) a) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a)))))))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a1')))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a2) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) a) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a))))))))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a2)))))))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) r)))))))))) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (a (c (fun (form) (recspace (list (char)))) _dest_form) (a (c (fun (recspace (list (char))) (form)) _mk_form) (v (recspace (list (char))) r)))) (v (recspace (list (char))) r))))))" 
	tag: TYPE_DEFINITION 
	type_definition { 
		type_name: "form" 
		abs_name: "_mk_form" 
		rep_name: "_dest_form" 
		theorem_arg: 999999999 
		}
    library_tag: "c-fDL.ml"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) form') (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) pform') (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) nform') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a0') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a0')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a)))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a0')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a))))))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0')))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a1') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) a) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a)))))))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a1')))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a2) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) a) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a))))))))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a2)))))))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a)))))))))))" 
	tag: THEOREM 
	training_split: TRAINING
    library_tag: "c-fDL.ml"
	pretty_printed: "|- ?a. !form' pform' nform'.      (!a0'. (?a. a0' = (\\a. CONSTR 0 (@v. T) (FCONS a (\\n. BOTTOM))) a /\\      pform' a) \\/ (?a. a0' =      (\\a. CONSTR (SUC 0) (@v. T) (FCONS a (\\n. BOTTOM))) a /\\      nform' a) ==> form' a0') /\\      (!a1'. (?a. a1' = (\\a. CONSTR (SUC (SUC 0)) a (\\n. BOTTOM)) a) \\/ (?a0 a1.      a1' =      (\\a0 a1.           CONSTR (SUC (SUC (SUC 0))) (@v. T)           (FCONS a0 (FCONS a1 (\\n. BOTTOM))))      a0      a1 /\\      form' a0 /\\      form' a1) \\/ (?a. a1' =      (\\a. CONSTR (SUC (SUC (SUC (SUC 0)))) (@v. T)           (FCONS a (\\n. BOTTOM)))      a /\\      form' a) ==> pform' a1') /\\      (!a2. (?a. a2 =     (\\a. CONSTR (SUC (SUC (SUC (SUC (SUC 0))))) a          (\\n. BOTTOM))     a) \\/      (?a0 a1.     a2 =     (\\a0 a1.          CONSTR (SUC (SUC (SUC (SUC (SUC (SUC 0))))))          (@v. T)          (FCONS a0 (FCONS a1 (\\n. BOTTOM))))     a0     a1 /\\     form' a0 /\\     form' a1) \\/      (?a0 a1.     a2 =     (\\a0 a1.          CONSTR (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0)))))))          (@v. T)          (FCONS a0 (FCONS a1 (\\n. BOTTOM))))     a0     a1 /\\     form' a0 /\\     form' a1) \\/      (?a. a2 =     (\\a. CONSTR          (SUC (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))))          (@v. T)          (FCONS a (\\n. BOTTOM)))     a /\\     form' a)      ==> nform' a2)      ==> pform' a" 
	proof_function: "type_definition_helper"
} 
theorems { 
	pretty_printed: "|- (!a. _mk_pform (_dest_pform a) = a) /\\ (!r. (!form' pform' nform'.  (!a0'. (?a. a0' =        (\\a. CONSTR 0 (@v. T) (FCONS a (\\n. BOTTOM))) a /\\        pform' a) \\/   (?a. a0' =        (\\a. CONSTR (SUC 0) (@v. T) (FCONS a (\\n. BOTTOM)))        a /\\        nform' a)   ==> form' a0') /\\  (!a1'. (?a. a1' = (\\a. CONSTR (SUC (SUC 0)) a (\\n. BOTTOM)) a) \\/   (?a0 a1.        a1' =        (\\a0 a1.             CONSTR (SUC (SUC (SUC 0))) (@v. T)             (FCONS a0 (FCONS a1 (\\n. BOTTOM))))        a0        a1 /\\        form' a0 /\\        form' a1) \\/   (?a. a1' =        (\\a. CONSTR (SUC (SUC (SUC (SUC 0)))) (@v. T)             (FCONS a (\\n. BOTTOM)))        a /\\        form' a)   ==> pform' a1') /\\  (!a2. (?a. a2 =       (\\a. CONSTR (SUC (SUC (SUC (SUC (SUC 0))))) a            (\\n. BOTTOM))       a) \\/  (?a0 a1.       a2 =       (\\a0 a1.            CONSTR (SUC (SUC (SUC (SUC (SUC (SUC 0))))))            (@v. T)            (FCONS a0 (FCONS a1 (\\n. BOTTOM))))       a0       a1 /\\       form' a0 /\\       form' a1) \\/  (?a0 a1.       a2 =       (\\a0 a1.            CONSTR            (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0)))))))            (@v. T)            (FCONS a0 (FCONS a1 (\\n. BOTTOM))))       a0       a1 /\\       form' a0 /\\       form' a1) \\/  (?a. a2 =       (\\a. CONSTR            (SUC            (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))))            (@v. T)            (FCONS a (\\n. BOTTOM)))       a /\\       form' a)  ==> nform' a2)  ==> pform' r) <=>   _dest_pform (_mk_pform r) = r)" 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (pform) (bool)) (bool)) !) (l (v (pform) a) (a (a (c (fun (pform) (fun (pform) (bool))) =) (a (c (fun (recspace (list (char))) (pform)) _mk_pform) (a (c (fun (pform) (recspace (list (char)))) _dest_pform) (v (pform) a)))) (v (pform) a))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) r) (a (a (c (fun (bool) (fun (bool) (bool))) =) (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) form') (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) pform') (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) nform') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a0') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a0')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a)))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a0')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a))))))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0')))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a1') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) a) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a)))))))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a1')))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a2) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) a) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a))))))))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a2)))))))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) r)))))))))) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (a (c (fun (pform) (recspace (list (char)))) _dest_pform) (a (c (fun (recspace (list (char))) (pform)) _mk_pform) (v (recspace (list (char))) r)))) (v (recspace (list (char))) r))))))" 
	tag: TYPE_DEFINITION 
	type_definition { 
		type_name: "pform" 
		abs_name: "_mk_pform" 
		rep_name: "_dest_pform" 
		theorem_arg: 999999999 
		}
    library_tag: "c-fDL.ml"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) form') (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) pform') (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) nform') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a0') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a0')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a)))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a0')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a))))))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0')))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a1') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) a) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a)))))))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a1')))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a2) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) a) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a))))))))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a2)))))))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a)))))))))))" 
	tag: THEOREM 
	training_split: TRAINING
    library_tag: "c-fDL.ml"
	pretty_printed: "|- ?a. !form' pform' nform'.      (!a0'. (?a. a0' = (\\a. CONSTR 0 (@v. T) (FCONS a (\\n. BOTTOM))) a /\\      pform' a) \\/ (?a. a0' =      (\\a. CONSTR (SUC 0) (@v. T) (FCONS a (\\n. BOTTOM))) a /\\      nform' a) ==> form' a0') /\\      (!a1'. (?a. a1' = (\\a. CONSTR (SUC (SUC 0)) a (\\n. BOTTOM)) a) \\/ (?a0 a1.      a1' =      (\\a0 a1.           CONSTR (SUC (SUC (SUC 0))) (@v. T)           (FCONS a0 (FCONS a1 (\\n. BOTTOM))))      a0      a1 /\\      form' a0 /\\      form' a1) \\/ (?a. a1' =      (\\a. CONSTR (SUC (SUC (SUC (SUC 0)))) (@v. T)           (FCONS a (\\n. BOTTOM)))      a /\\      form' a) ==> pform' a1') /\\      (!a2. (?a. a2 =     (\\a. CONSTR (SUC (SUC (SUC (SUC (SUC 0))))) a          (\\n. BOTTOM))     a) \\/      (?a0 a1.     a2 =     (\\a0 a1.          CONSTR (SUC (SUC (SUC (SUC (SUC (SUC 0))))))          (@v. T)          (FCONS a0 (FCONS a1 (\\n. BOTTOM))))     a0     a1 /\\     form' a0 /\\     form' a1) \\/      (?a0 a1.     a2 =     (\\a0 a1.          CONSTR (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0)))))))          (@v. T)          (FCONS a0 (FCONS a1 (\\n. BOTTOM))))     a0     a1 /\\     form' a0 /\\     form' a1) \\/      (?a. a2 =     (\\a. CONSTR          (SUC (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))))          (@v. T)          (FCONS a (\\n. BOTTOM)))     a /\\     form' a)      ==> nform' a2)      ==> nform' a" 
	proof_function: "type_definition_helper"
} 
theorems { 
	pretty_printed: "|- (!a. _mk_nform (_dest_nform a) = a) /\\ (!r. (!form' pform' nform'.  (!a0'. (?a. a0' =        (\\a. CONSTR 0 (@v. T) (FCONS a (\\n. BOTTOM))) a /\\        pform' a) \\/   (?a. a0' =        (\\a. CONSTR (SUC 0) (@v. T) (FCONS a (\\n. BOTTOM)))        a /\\        nform' a)   ==> form' a0') /\\  (!a1'. (?a. a1' = (\\a. CONSTR (SUC (SUC 0)) a (\\n. BOTTOM)) a) \\/   (?a0 a1.        a1' =        (\\a0 a1.             CONSTR (SUC (SUC (SUC 0))) (@v. T)             (FCONS a0 (FCONS a1 (\\n. BOTTOM))))        a0        a1 /\\        form' a0 /\\        form' a1) \\/   (?a. a1' =        (\\a. CONSTR (SUC (SUC (SUC (SUC 0)))) (@v. T)             (FCONS a (\\n. BOTTOM)))        a /\\        form' a)   ==> pform' a1') /\\  (!a2. (?a. a2 =       (\\a. CONSTR (SUC (SUC (SUC (SUC (SUC 0))))) a            (\\n. BOTTOM))       a) \\/  (?a0 a1.       a2 =       (\\a0 a1.            CONSTR (SUC (SUC (SUC (SUC (SUC (SUC 0))))))            (@v. T)            (FCONS a0 (FCONS a1 (\\n. BOTTOM))))       a0       a1 /\\       form' a0 /\\       form' a1) \\/  (?a0 a1.       a2 =       (\\a0 a1.            CONSTR            (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0)))))))            (@v. T)            (FCONS a0 (FCONS a1 (\\n. BOTTOM))))       a0       a1 /\\       form' a0 /\\       form' a1) \\/  (?a. a2 =       (\\a. CONSTR            (SUC            (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))))            (@v. T)            (FCONS a (\\n. BOTTOM)))       a /\\       form' a)  ==> nform' a2)  ==> nform' r) <=>   _dest_nform (_mk_nform r) = r)" 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (nform) (bool)) (bool)) !) (l (v (nform) a) (a (a (c (fun (nform) (fun (nform) (bool))) =) (a (c (fun (recspace (list (char))) (nform)) _mk_nform) (a (c (fun (nform) (recspace (list (char)))) _dest_nform) (v (nform) a)))) (v (nform) a))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) r) (a (a (c (fun (bool) (fun (bool) (bool))) =) (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) form') (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) pform') (a (c (fun (fun (fun (recspace (list (char))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (list (char))) (bool)) nform') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a0') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a0')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a)))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a0')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a))))))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0')))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a1') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) a) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a1')) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a)))))))) (a (v (fun (recspace (list (char))) (bool)) pform') (v (recspace (list (char))) a1')))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) !) (l (v (recspace (list (char))) a2) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) a) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a0) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (v (recspace (list (char))) a0)) (v (recspace (list (char))) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a0))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a1))))))))) (a (c (fun (fun (recspace (list (char))) (bool)) (bool)) ?) (l (v (recspace (list (char))) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (v (recspace (list (char))) a2)) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (v (recspace (list (char))) a)))) (a (v (fun (recspace (list (char))) (bool)) form') (v (recspace (list (char))) a))))))))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) a2)))))))) (a (v (fun (recspace (list (char))) (bool)) nform') (v (recspace (list (char))) r)))))))))) (a (a (c (fun (recspace (list (char))) (fun (recspace (list (char))) (bool))) =) (a (c (fun (nform) (recspace (list (char)))) _dest_nform) (a (c (fun (recspace (list (char))) (nform)) _mk_nform) (v (recspace (list (char))) r)))) (v (recspace (list (char))) r))))))" 
	tag: TYPE_DEFINITION 
	type_definition { 
		type_name: "nform" 
		abs_name: "_mk_nform" 
		rep_name: "_dest_nform" 
		theorem_arg: 999999999 
		}
    library_tag: "c-fDL.ml"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a) (a (c (fun (fun (fun (recspace (form)) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (form)) (bool)) strF') (a (c (fun (fun (fun (recspace (form)) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (form)) (bool)) strG') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (form)) (bool)) (bool)) !) (l (v (recspace (form)) a0') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (l (v (recspace (form)) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a)) (l (v (num) n) (c (recspace (form)) BOTTOM))))) (v (recspace (form)) a)))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a0) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (v (recspace (form)) a0)) (v (recspace (form)) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a0))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a1))))))))) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a))))))))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a0')))))) (a (c (fun (fun (recspace (form)) (bool)) (bool)) !) (l (v (recspace (form)) a1') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (l (v (recspace (form)) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a)) (l (v (num) n) (c (recspace (form)) BOTTOM))))) (v (recspace (form)) a)))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a0) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (v (recspace (form)) a0)) (v (recspace (form)) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a0))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a0) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (v (recspace (form)) a0)) (v (recspace (form)) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a0))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a1))))))))) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))))))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a1'))))))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a)))))))))" 
	tag: THEOREM 
	training_split: TRAINING
    library_tag: "c-fDL.ml"
	pretty_printed: "|- ?a. !strF' strG'.      (!a0'. (?a. a0' = (\\a. CONSTR 0 a (\\n. BOTTOM)) a) \\/ (?a. a0' =      (\\a. CONSTR (SUC 0) (@v. T) (FCONS a (\\n. BOTTOM))) a /\\      strF' a) \\/ (?a0 a1.      a0' =      (\\a0 a1.           CONSTR (SUC (SUC 0)) (@v. T)           (FCONS a0 (FCONS a1 (\\n. BOTTOM))))      a0      a1 /\\      strF' a0 /\\      strF' a1) \\/ (?a. a0' =      (\\a. CONSTR (SUC (SUC (SUC 0))) a (\\n. BOTTOM)) a) ==> strF' a0') /\\      (!a1'. (?a. a1' =      (\\a. CONSTR (SUC (SUC (SUC (SUC 0)))) a (\\n. BOTTOM))      a) \\/ (?a. a1' =      (\\a. CONSTR (SUC (SUC (SUC (SUC (SUC 0))))) (@v. T)           (FCONS a (\\n. BOTTOM)))      a /\\      strG' a) \\/ (?a0 a1.      a1' =      (\\a0 a1.           CONSTR (SUC (SUC (SUC (SUC (SUC (SUC 0))))))           (@v. T)           (FCONS a0 (FCONS a1 (\\n. BOTTOM))))      a0      a1 /\\      strG' a0 /\\      strF' a1) \\/ (?a0 a1.      a1' =      (\\a0 a1.           CONSTR           (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0)))))))           (@v. T)           (FCONS a0 (FCONS a1 (\\n. BOTTOM))))      a0      a1 /\\      strF' a0 /\\      strG' a1) \\/ (?a. a1' =      (\\a. CONSTR           (SUC (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))))           a           (\\n. BOTTOM))      a) ==> strG' a1')      ==> strF' a" 
	proof_function: "type_definition_helper"
} 
theorems { 
	pretty_printed: "|- (!a. _mk_strF (_dest_strF a) = a) /\\ (!r. (!strF' strG'.  (!a0'. (?a. a0' = (\\a. CONSTR 0 a (\\n. BOTTOM)) a) \\/   (?a. a0' =        (\\a. CONSTR (SUC 0) (@v. T) (FCONS a (\\n. BOTTOM)))        a /\\        strF' a) \\/   (?a0 a1.        a0' =        (\\a0 a1.             CONSTR (SUC (SUC 0)) (@v. T)             (FCONS a0 (FCONS a1 (\\n. BOTTOM))))        a0        a1 /\\        strF' a0 /\\        strF' a1) \\/   (?a. a0' =        (\\a. CONSTR (SUC (SUC (SUC 0))) a (\\n. BOTTOM)) a)   ==> strF' a0') /\\  (!a1'. (?a. a1' =        (\\a. CONSTR (SUC (SUC (SUC (SUC 0)))) a (\\n. BOTTOM))        a) \\/   (?a. a1' =        (\\a. CONSTR (SUC (SUC (SUC (SUC (SUC 0))))) (@v. T)             (FCONS a (\\n. BOTTOM)))        a /\\        strG' a) \\/   (?a0 a1.        a1' =        (\\a0 a1.             CONSTR (SUC (SUC (SUC (SUC (SUC (SUC 0))))))             (@v. T)             (FCONS a0 (FCONS a1 (\\n. BOTTOM))))        a0        a1 /\\        strG' a0 /\\        strF' a1) \\/   (?a0 a1.        a1' =        (\\a0 a1.             CONSTR             (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0)))))))             (@v. T)             (FCONS a0 (FCONS a1 (\\n. BOTTOM))))        a0        a1 /\\        strF' a0 /\\        strG' a1) \\/   (?a. a1' =        (\\a. CONSTR             (SUC             (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))))             a             (\\n. BOTTOM))        a)   ==> strG' a1')  ==> strF' r) <=>   _dest_strF (_mk_strF r) = r)" 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a) (a (a (c (fun (strF) (fun (strF) (bool))) =) (a (c (fun (recspace (form)) (strF)) _mk_strF) (a (c (fun (strF) (recspace (form))) _dest_strF) (v (strF) a)))) (v (strF) a))))) (a (c (fun (fun (recspace (form)) (bool)) (bool)) !) (l (v (recspace (form)) r) (a (a (c (fun (bool) (fun (bool) (bool))) =) (a (c (fun (fun (fun (recspace (form)) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (form)) (bool)) strF') (a (c (fun (fun (fun (recspace (form)) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (form)) (bool)) strG') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (form)) (bool)) (bool)) !) (l (v (recspace (form)) a0') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (l (v (recspace (form)) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a)) (l (v (num) n) (c (recspace (form)) BOTTOM))))) (v (recspace (form)) a)))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a0) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (v (recspace (form)) a0)) (v (recspace (form)) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a0))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a1))))))))) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a))))))))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a0')))))) (a (c (fun (fun (recspace (form)) (bool)) (bool)) !) (l (v (recspace (form)) a1') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (l (v (recspace (form)) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a)) (l (v (num) n) (c (recspace (form)) BOTTOM))))) (v (recspace (form)) a)))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a0) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (v (recspace (form)) a0)) (v (recspace (form)) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a0))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a0) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (v (recspace (form)) a0)) (v (recspace (form)) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a0))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a1))))))))) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))))))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a1'))))))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) r)))))))) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (a (c (fun (strF) (recspace (form))) _dest_strF) (a (c (fun (recspace (form)) (strF)) _mk_strF) (v (recspace (form)) r)))) (v (recspace (form)) r))))))" 
	tag: TYPE_DEFINITION 
	type_definition { 
		type_name: "strF" 
		abs_name: "_mk_strF" 
		rep_name: "_dest_strF" 
		theorem_arg: 999999999 
		}
    library_tag: "c-fDL.ml"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a) (a (c (fun (fun (fun (recspace (form)) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (form)) (bool)) strF') (a (c (fun (fun (fun (recspace (form)) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (form)) (bool)) strG') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (form)) (bool)) (bool)) !) (l (v (recspace (form)) a0') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (l (v (recspace (form)) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a)) (l (v (num) n) (c (recspace (form)) BOTTOM))))) (v (recspace (form)) a)))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a0) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (v (recspace (form)) a0)) (v (recspace (form)) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a0))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a1))))))))) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a))))))))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a0')))))) (a (c (fun (fun (recspace (form)) (bool)) (bool)) !) (l (v (recspace (form)) a1') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (l (v (recspace (form)) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a)) (l (v (num) n) (c (recspace (form)) BOTTOM))))) (v (recspace (form)) a)))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a0) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (v (recspace (form)) a0)) (v (recspace (form)) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a0))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a0) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (v (recspace (form)) a0)) (v (recspace (form)) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a0))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a1))))))))) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))))))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a1'))))))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a)))))))))" 
	tag: THEOREM 
	training_split: TRAINING
    library_tag: "c-fDL.ml"
	pretty_printed: "|- ?a. !strF' strG'.      (!a0'. (?a. a0' = (\\a. CONSTR 0 a (\\n. BOTTOM)) a) \\/ (?a. a0' =      (\\a. CONSTR (SUC 0) (@v. T) (FCONS a (\\n. BOTTOM))) a /\\      strF' a) \\/ (?a0 a1.      a0' =      (\\a0 a1.           CONSTR (SUC (SUC 0)) (@v. T)           (FCONS a0 (FCONS a1 (\\n. BOTTOM))))      a0      a1 /\\      strF' a0 /\\      strF' a1) \\/ (?a. a0' =      (\\a. CONSTR (SUC (SUC (SUC 0))) a (\\n. BOTTOM)) a) ==> strF' a0') /\\      (!a1'. (?a. a1' =      (\\a. CONSTR (SUC (SUC (SUC (SUC 0)))) a (\\n. BOTTOM))      a) \\/ (?a. a1' =      (\\a. CONSTR (SUC (SUC (SUC (SUC (SUC 0))))) (@v. T)           (FCONS a (\\n. BOTTOM)))      a /\\      strG' a) \\/ (?a0 a1.      a1' =      (\\a0 a1.           CONSTR (SUC (SUC (SUC (SUC (SUC (SUC 0))))))           (@v. T)           (FCONS a0 (FCONS a1 (\\n. BOTTOM))))      a0      a1 /\\      strG' a0 /\\      strF' a1) \\/ (?a0 a1.      a1' =      (\\a0 a1.           CONSTR           (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0)))))))           (@v. T)           (FCONS a0 (FCONS a1 (\\n. BOTTOM))))      a0      a1 /\\      strF' a0 /\\      strG' a1) \\/ (?a. a1' =      (\\a. CONSTR           (SUC (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))))           a           (\\n. BOTTOM))      a) ==> strG' a1')      ==> strG' a" 
	proof_function: "type_definition_helper"
} 
theorems { 
	pretty_printed: "|- (!a. _mk_strG (_dest_strG a) = a) /\\ (!r. (!strF' strG'.  (!a0'. (?a. a0' = (\\a. CONSTR 0 a (\\n. BOTTOM)) a) \\/   (?a. a0' =        (\\a. CONSTR (SUC 0) (@v. T) (FCONS a (\\n. BOTTOM)))        a /\\        strF' a) \\/   (?a0 a1.        a0' =        (\\a0 a1.             CONSTR (SUC (SUC 0)) (@v. T)             (FCONS a0 (FCONS a1 (\\n. BOTTOM))))        a0        a1 /\\        strF' a0 /\\        strF' a1) \\/   (?a. a0' =        (\\a. CONSTR (SUC (SUC (SUC 0))) a (\\n. BOTTOM)) a)   ==> strF' a0') /\\  (!a1'. (?a. a1' =        (\\a. CONSTR (SUC (SUC (SUC (SUC 0)))) a (\\n. BOTTOM))        a) \\/   (?a. a1' =        (\\a. CONSTR (SUC (SUC (SUC (SUC (SUC 0))))) (@v. T)             (FCONS a (\\n. BOTTOM)))        a /\\        strG' a) \\/   (?a0 a1.        a1' =        (\\a0 a1.             CONSTR (SUC (SUC (SUC (SUC (SUC (SUC 0))))))             (@v. T)             (FCONS a0 (FCONS a1 (\\n. BOTTOM))))        a0        a1 /\\        strG' a0 /\\        strF' a1) \\/   (?a0 a1.        a1' =        (\\a0 a1.             CONSTR             (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0)))))))             (@v. T)             (FCONS a0 (FCONS a1 (\\n. BOTTOM))))        a0        a1 /\\        strF' a0 /\\        strG' a1) \\/   (?a. a1' =        (\\a. CONSTR             (SUC             (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))))             a             (\\n. BOTTOM))        a)   ==> strG' a1')  ==> strG' r) <=>   _dest_strG (_mk_strG r) = r)" 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) a) (a (a (c (fun (strG) (fun (strG) (bool))) =) (a (c (fun (recspace (form)) (strG)) _mk_strG) (a (c (fun (strG) (recspace (form))) _dest_strG) (v (strG) a)))) (v (strG) a))))) (a (c (fun (fun (recspace (form)) (bool)) (bool)) !) (l (v (recspace (form)) r) (a (a (c (fun (bool) (fun (bool) (bool))) =) (a (c (fun (fun (fun (recspace (form)) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (form)) (bool)) strF') (a (c (fun (fun (fun (recspace (form)) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (form)) (bool)) strG') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (recspace (form)) (bool)) (bool)) !) (l (v (recspace (form)) a0') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (l (v (recspace (form)) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a)) (l (v (num) n) (c (recspace (form)) BOTTOM))))) (v (recspace (form)) a)))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a0) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (v (recspace (form)) a0)) (v (recspace (form)) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a0))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a1))))))))) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a0')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a))))))))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a0')))))) (a (c (fun (fun (recspace (form)) (bool)) (bool)) !) (l (v (recspace (form)) a1') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (l (v (recspace (form)) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a)) (l (v (num) n) (c (recspace (form)) BOTTOM))))) (v (recspace (form)) a)))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a0) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (v (recspace (form)) a0)) (v (recspace (form)) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a0))) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a0) (a (c (fun (fun (recspace (form)) (bool)) (bool)) ?) (l (v (recspace (form)) a1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (v (recspace (form)) a0)) (v (recspace (form)) a1)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (recspace (form)) (bool)) strF') (v (recspace (form)) a0))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a1))))))))) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) a) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (v (recspace (form)) a1')) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))))))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) a1'))))))) (a (v (fun (recspace (form)) (bool)) strG') (v (recspace (form)) r)))))))) (a (a (c (fun (recspace (form)) (fun (recspace (form)) (bool))) =) (a (c (fun (strG) (recspace (form))) _dest_strG) (a (c (fun (recspace (form)) (strG)) _mk_strG) (v (recspace (form)) r)))) (v (recspace (form)) r))))))" 
	tag: TYPE_DEFINITION 
	type_definition { 
		type_name: "strG" 
		abs_name: "_mk_strG" 
		rep_name: "_dest_strG" 
		theorem_arg: 999999999 
		}
    library_tag: "c-fDL.ml"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (c (fun (fun (recspace (prod (strF) (strG))) (bool)) (bool)) ?) (l (v (recspace (prod (strF) (strG))) a) (a (c (fun (fun (fun (recspace (prod (strF) (strG))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (prod (strF) (strG))) (bool)) seq') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (fun (recspace (prod (strF) (strG))) (bool)) (bool)) !) (l (v (recspace (prod (strF) (strG))) a) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) a0) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) a1) (a (a (c (fun (recspace (prod (strF) (strG))) (fun (recspace (prod (strF) (strG))) (bool))) =) (v (recspace (prod (strF) (strG))) a)) (a (a (l (v (strF) a0) (l (v (strG) a1) (a (a (a (c (fun (num) (fun (prod (strF) (strG)) (fun (fun (num) (recspace (prod (strF) (strG)))) (recspace (prod (strF) (strG)))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (a (a (c (fun (strF) (fun (strG) (prod (strF) (strG)))) ,) (v (strF) a0)) (v (strG) a1))) (l (v (num) n) (c (recspace (prod (strF) (strG))) BOTTOM))))) (v (strF) a0)) (v (strG) a1)))))))) (a (v (fun (recspace (prod (strF) (strG))) (bool)) seq') (v (recspace (prod (strF) (strG))) a)))))) (a (v (fun (recspace (prod (strF) (strG))) (bool)) seq') (v (recspace (prod (strF) (strG))) a)))))))" 
	tag: THEOREM 
	training_split: TRAINING
    library_tag: "c-fDL.ml"
	pretty_printed: "|- ?a. !seq'. (!a. (?a0 a1.       a = (\\a0 a1. CONSTR 0 (a0,a1) (\\n. BOTTOM)) a0 a1)  ==> seq' a)   ==> seq' a" 
	proof_function: "type_definition_helper"
} 
theorems { 
	pretty_printed: "|- (!a. _mk_seq (_dest_seq a) = a) /\\ (!r. (!seq'. (!a. (?a0 a1.         a = (\\a0 a1. CONSTR 0 (a0,a1) (\\n. BOTTOM)) a0 a1)    ==> seq' a)     ==> seq' r) <=>   _dest_seq (_mk_seq r) = r)" 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (seq) (bool)) (bool)) !) (l (v (seq) a) (a (a (c (fun (seq) (fun (seq) (bool))) =) (a (c (fun (recspace (prod (strF) (strG))) (seq)) _mk_seq) (a (c (fun (seq) (recspace (prod (strF) (strG)))) _dest_seq) (v (seq) a)))) (v (seq) a))))) (a (c (fun (fun (recspace (prod (strF) (strG))) (bool)) (bool)) !) (l (v (recspace (prod (strF) (strG))) r) (a (a (c (fun (bool) (fun (bool) (bool))) =) (a (c (fun (fun (fun (recspace (prod (strF) (strG))) (bool)) (bool)) (bool)) !) (l (v (fun (recspace (prod (strF) (strG))) (bool)) seq') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (fun (recspace (prod (strF) (strG))) (bool)) (bool)) !) (l (v (recspace (prod (strF) (strG))) a) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) a0) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) a1) (a (a (c (fun (recspace (prod (strF) (strG))) (fun (recspace (prod (strF) (strG))) (bool))) =) (v (recspace (prod (strF) (strG))) a)) (a (a (l (v (strF) a0) (l (v (strG) a1) (a (a (a (c (fun (num) (fun (prod (strF) (strG)) (fun (fun (num) (recspace (prod (strF) (strG)))) (recspace (prod (strF) (strG)))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (a (a (c (fun (strF) (fun (strG) (prod (strF) (strG)))) ,) (v (strF) a0)) (v (strG) a1))) (l (v (num) n) (c (recspace (prod (strF) (strG))) BOTTOM))))) (v (strF) a0)) (v (strG) a1)))))))) (a (v (fun (recspace (prod (strF) (strG))) (bool)) seq') (v (recspace (prod (strF) (strG))) a)))))) (a (v (fun (recspace (prod (strF) (strG))) (bool)) seq') (v (recspace (prod (strF) (strG))) r)))))) (a (a (c (fun (recspace (prod (strF) (strG))) (fun (recspace (prod (strF) (strG))) (bool))) =) (a (c (fun (seq) (recspace (prod (strF) (strG)))) _dest_seq) (a (c (fun (recspace (prod (strF) (strG))) (seq)) _mk_seq) (v (recspace (prod (strF) (strG))) r)))) (v (recspace (prod (strF) (strG))) r))))))" 
	tag: TYPE_DEFINITION 
	type_definition { 
		type_name: "seq" 
		abs_name: "_mk_seq" 
		rep_name: "_dest_seq" 
		theorem_arg: 999999999 
		}
    library_tag: "c-fDL.ml"
}











theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (form) (nform)) (fun (fun (form) (nform)) (bool))) =) (c (fun (form) (nform)) ||)) (l (v (form) a) (a (c (fun (recspace (list (char))) (nform)) _mk_nform) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (form) (nform)) (fun (fun (form) (nform)) (bool))) =) (v (fun (form) (nform)) ||)) (l (v (form) a) (a (c (fun (recspace (list (char))) (nform)) _mk_nform) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a))))))" 
		constants: "||"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- || = (\\a. _mk_nform   ((\\a. CONSTR (SUC (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))))   (@v. T)   (FCONS a (\\n. BOTTOM)))   (_dest_form a)))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (nform) (form)) (fun (fun (nform) (form)) (bool))) =) (c (fun (nform) (form)) nn)) (l (v (nform) a) (a (c (fun (recspace (list (char))) (form)) _mk_form) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (a (c (fun (nform) (recspace (list (char)))) _dest_nform) (v (nform) a))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (nform) (form)) (fun (fun (nform) (form)) (bool))) =) (v (fun (nform) (form)) nn)) (l (v (nform) a) (a (c (fun (recspace (list (char))) (form)) _mk_form) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (a (c (fun (nform) (recspace (list (char)))) _dest_nform) (v (nform) a))))))" 
		constants: "nn"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- nn = (\\a. _mk_form   ((\\a. CONSTR (SUC 0) (@v. T) (FCONS a (\\n. BOTTOM))) (_dest_nform a)))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (pform) (form)) (fun (fun (pform) (form)) (bool))) =) (c (fun (pform) (form)) pp)) (l (v (pform) a) (a (c (fun (recspace (list (char))) (form)) _mk_form) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (a (c (fun (pform) (recspace (list (char)))) _dest_pform) (v (pform) a))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (pform) (form)) (fun (fun (pform) (form)) (bool))) =) (v (fun (pform) (form)) pp)) (l (v (pform) a) (a (c (fun (recspace (list (char))) (form)) _mk_form) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (a (c (fun (pform) (recspace (list (char)))) _dest_pform) (v (pform) a))))))" 
		constants: "pp"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- pp = (\\a. _mk_form   ((\\a. CONSTR 0 (@v. T) (FCONS a (\\n. BOTTOM))) (_dest_pform a)))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (strG) (fun (strF) (strG))) (fun (fun (strG) (fun (strF) (strG))) (bool))) =) (c (fun (strG) (fun (strF) (strG))) /.^)) (l (v (strG) a0) (l (v (strF) a1) (a (c (fun (recspace (form)) (strG)) _mk_strG) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (a (c (fun (strG) (recspace (form))) _dest_strG) (v (strG) a0))) (a (c (fun (strF) (recspace (form))) _dest_strF) (v (strF) a1)))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (strG) (fun (strF) (strG))) (fun (fun (strG) (fun (strF) (strG))) (bool))) =) (v (fun (strG) (fun (strF) (strG))) /.^)) (l (v (strG) a0) (l (v (strF) a1) (a (c (fun (recspace (form)) (strG)) _mk_strG) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (a (c (fun (strG) (recspace (form))) _dest_strG) (v (strG) a0))) (a (c (fun (strF) (recspace (form))) _dest_strF) (v (strF) a1)))))))" 
		constants: "/.^"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- /.^ = (\\a0 a1.   _mk_strG   ((\\a0 a1.   CONSTR (SUC (SUC (SUC (SUC (SUC (SUC 0)))))) (@v. T)   (FCONS a0 (FCONS a1 (\\n. BOTTOM))))    (_dest_strG a0)   (_dest_strF a1)))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (form) (strF)) (fun (fun (form) (strF)) (bool))) =) (c (fun (form) (strF)) ff)) (l (v (form) a) (a (c (fun (recspace (form)) (strF)) _mk_strF) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (form) (strF)) (fun (fun (form) (strF)) (bool))) =) (v (fun (form) (strF)) ff)) (l (v (form) a) (a (c (fun (recspace (form)) (strF)) _mk_strF) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))" 
		constants: "ff"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- ff = (\\a. _mk_strF ((\\a. CONSTR 0 a (\\n. BOTTOM)) a))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (strF) (strF)) (fun (fun (strF) (strF)) (bool))) =) (c (fun (strF) (strF)) <>^)) (l (v (strF) a) (a (c (fun (recspace (form)) (strF)) _mk_strF) (a (l (v (recspace (form)) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a)) (l (v (num) n) (c (recspace (form)) BOTTOM))))) (a (c (fun (strF) (recspace (form))) _dest_strF) (v (strF) a))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (strF) (strF)) (fun (fun (strF) (strF)) (bool))) =) (v (fun (strF) (strF)) <>^)) (l (v (strF) a) (a (c (fun (recspace (form)) (strF)) _mk_strF) (a (l (v (recspace (form)) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a)) (l (v (num) n) (c (recspace (form)) BOTTOM))))) (a (c (fun (strF) (recspace (form))) _dest_strF) (v (strF) a))))))" 
		constants: "<>^"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- <>^ = (\\a. _mk_strF   ((\\a. CONSTR (SUC 0) (@v. T) (FCONS a (\\n. BOTTOM))) (_dest_strF a)))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (form) (strG)) (fun (fun (form) (strG)) (bool))) =) (c (fun (form) (strG)) gg)) (l (v (form) a) (a (c (fun (recspace (form)) (strG)) _mk_strG) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (form) (strG)) (fun (fun (form) (strG)) (bool))) =) (v (fun (form) (strG)) gg)) (l (v (form) a) (a (c (fun (recspace (form)) (strG)) _mk_strG) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))" 
		constants: "gg"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- gg = (\\a. _mk_strG ((\\a. CONSTR (SUC (SUC (SUC (SUC 0)))) a (\\n. BOTTOM)) a))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (strG) (strG)) (fun (fun (strG) (strG)) (bool))) =) (c (fun (strG) (strG)) ||^)) (l (v (strG) a) (a (c (fun (recspace (form)) (strG)) _mk_strG) (a (l (v (recspace (form)) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a)) (l (v (num) n) (c (recspace (form)) BOTTOM))))) (a (c (fun (strG) (recspace (form))) _dest_strG) (v (strG) a))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (strG) (strG)) (fun (fun (strG) (strG)) (bool))) =) (v (fun (strG) (strG)) ||^)) (l (v (strG) a) (a (c (fun (recspace (form)) (strG)) _mk_strG) (a (l (v (recspace (form)) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a)) (l (v (num) n) (c (recspace (form)) BOTTOM))))) (a (c (fun (strG) (recspace (form))) _dest_strG) (v (strG) a))))))" 
		constants: "||^"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- ||^ = (\\a. _mk_strG   ((\\a. CONSTR (SUC (SUC (SUC (SUC (SUC 0))))) (@v. T)   (FCONS a (\\n. BOTTOM)))   (_dest_strG a)))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (form) (fun (form) (nform))) (fun (fun (form) (fun (form) (nform))) (bool))) =) (c (fun (form) (fun (form) (nform))) /.)) (l (v (form) a0) (l (v (form) a1) (a (c (fun (recspace (list (char))) (nform)) _mk_nform) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a0))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a1)))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (form) (fun (form) (nform))) (fun (fun (form) (fun (form) (nform))) (bool))) =) (v (fun (form) (fun (form) (nform))) /.)) (l (v (form) a0) (l (v (form) a1) (a (c (fun (recspace (list (char))) (nform)) _mk_nform) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a0))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a1)))))))" 
		constants: "/."
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- /. = (\\a0 a1.   _mk_nform   ((\\a0 a1.   CONSTR (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))) (@v. T)   (FCONS a0 (FCONS a1 (\\n. BOTTOM))))    (_dest_form a0)   (_dest_form a1)))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (list (char)) (pform)) (fun (fun (list (char)) (pform)) (bool))) =) (c (fun (list (char)) (pform)) pAtom)) (l (v (list (char)) a) (a (c (fun (recspace (list (char))) (pform)) _mk_pform) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (list (char)) (pform)) (fun (fun (list (char)) (pform)) (bool))) =) (v (fun (list (char)) (pform)) pAtom)) (l (v (list (char)) a) (a (c (fun (recspace (list (char))) (pform)) _mk_pform) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))" 
		constants: "pAtom"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- pAtom = (\\a. _mk_pform ((\\a. CONSTR (SUC (SUC 0)) a (\\n. BOTTOM)) a))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (num) (string)) (fun (fun (num) (string)) (bool))) =) (c (fun (num) (string)) String)) (l (v (num) a) (a (c (fun (recspace (num)) (string)) _mk_string) (a (l (v (num) a) (a (a (a (c (fun (num) (fun (num) (fun (fun (num) (recspace (num))) (recspace (num))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (v (num) a)) (l (v (num) n) (c (recspace (num)) BOTTOM)))) (v (num) a)))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (num) (string)) (fun (fun (num) (string)) (bool))) =) (v (fun (num) (string)) String)) (l (v (num) a) (a (c (fun (recspace (num)) (string)) _mk_string) (a (l (v (num) a) (a (a (a (c (fun (num) (fun (num) (fun (fun (num) (recspace (num))) (recspace (num))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (v (num) a)) (l (v (num) n) (c (recspace (num)) BOTTOM)))) (v (num) a)))))" 
		constants: "String"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- String = (\\a. _mk_string ((\\a. CONSTR 0 a (\\n. BOTTOM)) a))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (strF) (fun (strG) (strG))) (fun (fun (strF) (fun (strG) (strG))) (bool))) =) (c (fun (strF) (fun (strG) (strG))) \\.^)) (l (v (strF) a0) (l (v (strG) a1) (a (c (fun (recspace (form)) (strG)) _mk_strG) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (a (c (fun (strF) (recspace (form))) _dest_strF) (v (strF) a0))) (a (c (fun (strG) (recspace (form))) _dest_strG) (v (strG) a1)))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (strF) (fun (strG) (strG))) (fun (fun (strF) (fun (strG) (strG))) (bool))) =) (v (fun (strF) (fun (strG) (strG))) \\.^)) (l (v (strF) a0) (l (v (strG) a1) (a (c (fun (recspace (form)) (strG)) _mk_strG) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (a (c (fun (strF) (recspace (form))) _dest_strF) (v (strF) a0))) (a (c (fun (strG) (recspace (form))) _dest_strG) (v (strG) a1)))))))" 
		constants: "\\.^"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- \\.^ = (\\a0 a1.   _mk_strG   ((\\a0 a1.   CONSTR (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0))))))) (@v. T)   (FCONS a0 (FCONS a1 (\\n. BOTTOM))))    (_dest_strF a0)   (_dest_strG a1)))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (form) (strF)) (fun (fun (form) (strF)) (bool))) =) (c (fun (form) (strF)) focf)) (l (v (form) a) (a (c (fun (recspace (form)) (strF)) _mk_strF) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (form) (strF)) (fun (fun (form) (strF)) (bool))) =) (v (fun (form) (strF)) focf)) (l (v (form) a) (a (c (fun (recspace (form)) (strF)) _mk_strF) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))" 
		constants: "focf"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- focf = (\\a. _mk_strF ((\\a. CONSTR (SUC (SUC (SUC 0))) a (\\n. BOTTOM)) a))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (form) (fun (form) (pform))) (fun (fun (form) (fun (form) (pform))) (bool))) =) (c (fun (form) (fun (form) (pform))) **)) (l (v (form) a0) (l (v (form) a1) (a (c (fun (recspace (list (char))) (pform)) _mk_pform) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a0))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a1)))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (form) (fun (form) (pform))) (fun (fun (form) (fun (form) (pform))) (bool))) =) (v (fun (form) (fun (form) (pform))) **)) (l (v (form) a0) (l (v (form) a1) (a (c (fun (recspace (list (char))) (pform)) _mk_pform) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a0))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a1)))))))" 
		constants: "**"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- (**) = (\\a0 a1.   _mk_pform   ((\\a0 a1.   CONSTR (SUC (SUC (SUC 0))) (@v. T)   (FCONS a0 (FCONS a1 (\\n. BOTTOM))))    (_dest_form a0)   (_dest_form a1)))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (strF) (fun (strG) (seq))) (fun (fun (strF) (fun (strG) (seq))) (bool))) =) (c (fun (strF) (fun (strG) (seq))) -->)) (l (v (strF) a0) (l (v (strG) a1) (a (c (fun (recspace (prod (strF) (strG))) (seq)) _mk_seq) (a (a (l (v (strF) a0) (l (v (strG) a1) (a (a (a (c (fun (num) (fun (prod (strF) (strG)) (fun (fun (num) (recspace (prod (strF) (strG)))) (recspace (prod (strF) (strG)))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (a (a (c (fun (strF) (fun (strG) (prod (strF) (strG)))) ,) (v (strF) a0)) (v (strG) a1))) (l (v (num) n) (c (recspace (prod (strF) (strG))) BOTTOM))))) (v (strF) a0)) (v (strG) a1))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (strF) (fun (strG) (seq))) (fun (fun (strF) (fun (strG) (seq))) (bool))) =) (v (fun (strF) (fun (strG) (seq))) -->)) (l (v (strF) a0) (l (v (strG) a1) (a (c (fun (recspace (prod (strF) (strG))) (seq)) _mk_seq) (a (a (l (v (strF) a0) (l (v (strG) a1) (a (a (a (c (fun (num) (fun (prod (strF) (strG)) (fun (fun (num) (recspace (prod (strF) (strG)))) (recspace (prod (strF) (strG)))))) CONSTR) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))) (a (a (c (fun (strF) (fun (strG) (prod (strF) (strG)))) ,) (v (strF) a0)) (v (strG) a1))) (l (v (num) n) (c (recspace (prod (strF) (strG))) BOTTOM))))) (v (strF) a0)) (v (strG) a1))))))" 
		constants: "-->"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- --> = (\\a0 a1. _mk_seq ((\\a0 a1. CONSTR 0 (a0,a1) (\\n. BOTTOM)) a0 a1))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (strF) (fun (strF) (strF))) (fun (fun (strF) (fun (strF) (strF))) (bool))) =) (c (fun (strF) (fun (strF) (strF))) **^)) (l (v (strF) a0) (l (v (strF) a1) (a (c (fun (recspace (form)) (strF)) _mk_strF) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (a (c (fun (strF) (recspace (form))) _dest_strF) (v (strF) a0))) (a (c (fun (strF) (recspace (form))) _dest_strF) (v (strF) a1)))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (strF) (fun (strF) (strF))) (fun (fun (strF) (fun (strF) (strF))) (bool))) =) (v (fun (strF) (fun (strF) (strF))) **^)) (l (v (strF) a0) (l (v (strF) a1) (a (c (fun (recspace (form)) (strF)) _mk_strF) (a (a (l (v (recspace (form)) a0) (l (v (recspace (form)) a1) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))) (a (c (fun (fun (form) (bool)) (form)) @) (l (v (form) v) (c (bool) T)))) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a0)) (a (a (c (fun (recspace (form)) (fun (fun (num) (recspace (form))) (fun (num) (recspace (form))))) FCONS) (v (recspace (form)) a1)) (l (v (num) n) (c (recspace (form)) BOTTOM))))))) (a (c (fun (strF) (recspace (form))) _dest_strF) (v (strF) a0))) (a (c (fun (strF) (recspace (form))) _dest_strF) (v (strF) a1)))))))" 
		constants: "**^"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- **^ = (\\a0 a1.   _mk_strF   ((\\a0 a1.   CONSTR (SUC (SUC 0)) (@v. T) (FCONS a0 (FCONS a1 (\\n. BOTTOM))))    (_dest_strF a0)   (_dest_strF a1)))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (form) (pform)) (fun (fun (form) (pform)) (bool))) =) (c (fun (form) (pform)) <>)) (l (v (form) a) (a (c (fun (recspace (list (char))) (pform)) _mk_pform) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (form) (pform)) (fun (fun (form) (pform)) (bool))) =) (v (fun (form) (pform)) <>)) (l (v (form) a) (a (c (fun (recspace (list (char))) (pform)) _mk_pform) (a (l (v (recspace (list (char))) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a))))))" 
		constants: "<>"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- <> = (\\a. _mk_pform   ((\\a. CONSTR (SUC (SUC (SUC (SUC 0)))) (@v. T) (FCONS a (\\n. BOTTOM)))   (_dest_form a)))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (form) (strG)) (fun (fun (form) (strG)) (bool))) =) (c (fun (form) (strG)) focg)) (l (v (form) a) (a (c (fun (recspace (form)) (strG)) _mk_strG) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (form) (strG)) (fun (fun (form) (strG)) (bool))) =) (v (fun (form) (strG)) focg)) (l (v (form) a) (a (c (fun (recspace (form)) (strG)) _mk_strG) (a (l (v (form) a) (a (a (a (c (fun (num) (fun (form) (fun (fun (num) (recspace (form))) (recspace (form))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))))) (v (form) a)) (l (v (num) n) (c (recspace (form)) BOTTOM)))) (v (form) a)))))" 
		constants: "focg"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- focg = (\\a. _mk_strG   ((\\a. CONSTR (SUC (SUC (SUC (SUC (SUC (SUC (SUC (SUC 0)))))))) a   (\\n. BOTTOM))   a))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (form) (fun (form) (nform))) (fun (fun (form) (fun (form) (nform))) (bool))) =) (c (fun (form) (fun (form) (nform))) \\.)) (l (v (form) a0) (l (v (form) a1) (a (c (fun (recspace (list (char))) (nform)) _mk_nform) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a0))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a1)))))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (form) (fun (form) (nform))) (fun (fun (form) (fun (form) (nform))) (bool))) =) (v (fun (form) (fun (form) (nform))) \\.)) (l (v (form) a0) (l (v (form) a1) (a (c (fun (recspace (list (char))) (nform)) _mk_nform) (a (a (l (v (recspace (list (char))) a0) (l (v (recspace (list (char))) a1) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0))))))))) (a (c (fun (fun (list (char)) (bool)) (list (char))) @) (l (v (list (char)) v) (c (bool) T)))) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a0)) (a (a (c (fun (recspace (list (char))) (fun (fun (num) (recspace (list (char)))) (fun (num) (recspace (list (char)))))) FCONS) (v (recspace (list (char))) a1)) (l (v (num) n) (c (recspace (list (char))) BOTTOM))))))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a0))) (a (c (fun (form) (recspace (list (char)))) _dest_form) (v (form) a1)))))))" 
		constants: "\\."
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- \\. = (\\a0 a1.   _mk_nform   ((\\a0 a1.   CONSTR (SUC (SUC (SUC (SUC (SUC (SUC 0)))))) (@v. T)   (FCONS a0 (FCONS a1 (\\n. BOTTOM))))    (_dest_form a0)   (_dest_form a1)))"
}

theorems { 
	fingerprint: 999999999 
	conclusion: "(a (a (c (fun (fun (list (char)) (nform)) (fun (fun (list (char)) (nform)) (bool))) =) (c (fun (list (char)) (nform)) nAtom)) (l (v (list (char)) a) (a (c (fun (recspace (list (char))) (nform)) _mk_nform) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))" 
	tag: DEFINITION 
	definition { 
		definition_type: "DRULE"  
		definition_term: "(a (a (c (fun (fun (list (char)) (nform)) (fun (fun (list (char)) (nform)) (bool))) =) (v (fun (list (char)) (nform)) nAtom)) (l (v (list (char)) a) (a (c (fun (recspace (list (char))) (nform)) _mk_nform) (a (l (v (list (char)) a) (a (a (a (c (fun (num) (fun (list (char)) (fun (fun (num) (recspace (list (char)))) (recspace (list (char)))))) CONSTR) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) SUC) (a (c (fun (num) (num)) NUMERAL) (c (num) _0)))))))) (v (list (char)) a)) (l (v (num) n) (c (recspace (list (char))) BOTTOM)))) (v (list (char)) a)))))" 
		constants: "nAtom"
	} 
    library_tag: "c-fDL.ml"
	pretty_printed: "|- nAtom = (\\a. _mk_nform   ((\\a. CONSTR (SUC (SUC (SUC (SUC (SUC 0))))) a (\\n. BOTTOM)) a))"
}







theorems {
  conclusion:  "(a (c (fun (fun (fun (string) (bool)) (bool)) (bool)) !) (l (v (fun (string) (bool)) P) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (fun (num) (bool)) (bool)) !) (l (v (num) a) (a (v (fun (string) (bool)) P) (a (c (fun (num) (string)) String) (v (num) a)))))) (a (c (fun (fun (string) (bool)) (bool)) !) (l (v (string) x) (a (v (fun (string) (bool)) P) (v (string) x)))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 441653579546696989
  library_tag: "c-fDL.ml"
  pretty_printed: "|- !P. (!a. P (String a)) ==> (!x. P x)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 441653579546696989
}

theorems {
  conclusion:  "(a (c (fun (fun (fun (num) Z) (bool)) (bool)) !) (l (v (fun (num) Z) String') (a (c (fun (fun (fun (string) Z) (bool)) (bool)) ?) (l (v (fun (string) Z) fn) (a (c (fun (fun (num) (bool)) (bool)) !) (l (v (num) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (string) Z) fn) (a (c (fun (num) (string)) String) (v (num) a)))) (a (v (fun (num) Z) String') (v (num) a)))))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 4611157912544210
  library_tag: "c-fDL.ml"
  pretty_printed: "|- !String'. ?fn. !a. fn (String a) = String' a"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 4611157912544210
}

theorems {
  conclusion:  "(a (c (fun (fun (fun (form) (bool)) (bool)) (bool)) !) (l (v (fun (form) (bool)) P0) (a (c (fun (fun (fun (pform) (bool)) (bool)) (bool)) !) (l (v (fun (pform) (bool)) P1) (a (c (fun (fun (fun (nform) (bool)) (bool)) (bool)) !) (l (v (fun (nform) (bool)) P2) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (pform) (bool)) (bool)) !) (l (v (pform) a) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (pform) (bool)) P1) (v (pform) a))) (a (v (fun (form) (bool)) P0) (a (c (fun (pform) (form)) pp) (v (pform) a))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (nform) (bool)) (bool)) !) (l (v (nform) a) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (nform) (bool)) P2) (v (nform) a))) (a (v (fun (form) (bool)) P0) (a (c (fun (nform) (form)) nn) (v (nform) a))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (list (char)) (bool)) (bool)) !) (l (v (list (char)) a) (a (v (fun (pform) (bool)) P1) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a0) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a1) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (form) (bool)) P0) (v (form) a0))) (a (v (fun (form) (bool)) P0) (v (form) a1)))) (a (v (fun (pform) (bool)) P1) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) a0)) (v (form) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (form) (bool)) P0) (v (form) a))) (a (v (fun (pform) (bool)) P1) (a (c (fun (form) (pform)) <>) (v (form) a))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (list (char)) (bool)) (bool)) !) (l (v (list (char)) a) (a (v (fun (nform) (bool)) P2) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a0) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a1) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (form) (bool)) P0) (v (form) a0))) (a (v (fun (form) (bool)) P0) (v (form) a1)))) (a (v (fun (nform) (bool)) P2) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) a0)) (v (form) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a0) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a1) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (form) (bool)) P0) (v (form) a0))) (a (v (fun (form) (bool)) P0) (v (form) a1)))) (a (v (fun (nform) (bool)) P2) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) a0)) (v (form) a1))))))))) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (form) (bool)) P0) (v (form) a))) (a (v (fun (nform) (bool)) P2) (a (c (fun (form) (nform)) ||) (v (form) a))))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) x0) (a (v (fun (form) (bool)) P0) (v (form) x0))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (pform) (bool)) (bool)) !) (l (v (pform) x1) (a (v (fun (pform) (bool)) P1) (v (pform) x1))))) (a (c (fun (fun (nform) (bool)) (bool)) !) (l (v (nform) x2) (a (v (fun (nform) (bool)) P2) (v (nform) x2)))))))))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 2677193548554991439
  library_tag: "c-fDL.ml"
  pretty_printed: "|- !P0 P1 P2. (!a. P1 a ==> P0 (pp a)) /\  (!a. P2 a ==> P0 (nn a)) /\ (!a. P1 (pAtom a)) /\ (!a0 a1. P0 a0 /\ P0 a1 ==> P1 (a0 ** a1)) /\ (!a. P0 a ==> P1 (<>a)) /\ (!a. P2 (nAtom a)) /\ (!a0 a1. P0 a0 /\ P0 a1 ==> P2 (a0 \. a1)) /\ (!a0 a1. P0 a0 /\ P0 a1 ==> P2 (a0 /. a1)) /\ (!a. P0 a ==> P2 (||a)) ==> (!x0. P0 x0) /\ (!x1. P1 x1) /\ (!x2. P2 x2)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 2677193548554991439
}

theorems {
  conclusion:  "(a (c (fun (fun (fun (pform) (fun Z Z)) (bool)) (bool)) !) (l (v (fun (pform) (fun Z Z)) pp') (a (c (fun (fun (fun (nform) (fun Z Z)) (bool)) (bool)) !) (l (v (fun (nform) (fun Z Z)) nn') (a (c (fun (fun (fun (list (char)) Z) (bool)) (bool)) !) (l (v (fun (list (char)) Z) pAtom') (a (c (fun (fun (fun (form) (fun (form) (fun Z (fun Z Z)))) (bool)) (bool)) !) (l (v (fun (form) (fun (form) (fun Z (fun Z Z)))) **') (a (c (fun (fun (fun (form) (fun Z Z)) (bool)) (bool)) !) (l (v (fun (form) (fun Z Z)) <>') (a (c (fun (fun (fun (list (char)) Z) (bool)) (bool)) !) (l (v (fun (list (char)) Z) nAtom') (a (c (fun (fun (fun (form) (fun (form) (fun Z (fun Z Z)))) (bool)) (bool)) !) (l (v (fun (form) (fun (form) (fun Z (fun Z Z)))) \\.') (a (c (fun (fun (fun (form) (fun (form) (fun Z (fun Z Z)))) (bool)) (bool)) !) (l (v (fun (form) (fun (form) (fun Z (fun Z Z)))) /.') (a (c (fun (fun (fun (form) (fun Z Z)) (bool)) (bool)) !) (l (v (fun (form) (fun Z Z)) ||') (a (c (fun (fun (fun (form) Z) (bool)) (bool)) ?) (l (v (fun (form) Z) fn0) (a (c (fun (fun (fun (nform) Z) (bool)) (bool)) ?) (l (v (fun (nform) Z) fn1) (a (c (fun (fun (fun (pform) Z) (bool)) (bool)) ?) (l (v (fun (pform) Z) fn2) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (pform) (bool)) (bool)) !) (l (v (pform) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (form) Z) fn0) (a (c (fun (pform) (form)) pp) (v (pform) a)))) (a (a (v (fun (pform) (fun Z Z)) pp') (v (pform) a)) (a (v (fun (pform) Z) fn2) (v (pform) a))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (nform) (bool)) (bool)) !) (l (v (nform) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (form) Z) fn0) (a (c (fun (nform) (form)) nn) (v (nform) a)))) (a (a (v (fun (nform) (fun Z Z)) nn') (v (nform) a)) (a (v (fun (nform) Z) fn1) (v (nform) a))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (list (char)) (bool)) (bool)) !) (l (v (list (char)) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (pform) Z) fn2) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) a)))) (a (v (fun (list (char)) Z) pAtom') (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a0) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a1) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (pform) Z) fn2) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) a0)) (v (form) a1)))) (a (a (a (a (v (fun (form) (fun (form) (fun Z (fun Z Z)))) **') (v (form) a0)) (v (form) a1)) (a (v (fun (form) Z) fn0) (v (form) a0))) (a (v (fun (form) Z) fn0) (v (form) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (pform) Z) fn2) (a (c (fun (form) (pform)) <>) (v (form) a)))) (a (a (v (fun (form) (fun Z Z)) <>') (v (form) a)) (a (v (fun (form) Z) fn0) (v (form) a))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (list (char)) (bool)) (bool)) !) (l (v (list (char)) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (nform) Z) fn1) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) a)))) (a (v (fun (list (char)) Z) nAtom') (v (list (char)) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a0) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a1) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (nform) Z) fn1) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) a0)) (v (form) a1)))) (a (a (a (a (v (fun (form) (fun (form) (fun Z (fun Z Z)))) \\.') (v (form) a0)) (v (form) a1)) (a (v (fun (form) Z) fn0) (v (form) a0))) (a (v (fun (form) Z) fn0) (v (form) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a0) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a1) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (nform) Z) fn1) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) a0)) (v (form) a1)))) (a (a (a (a (v (fun (form) (fun (form) (fun Z (fun Z Z)))) /.') (v (form) a0)) (v (form) a1)) (a (v (fun (form) Z) fn0) (v (form) a0))) (a (v (fun (form) Z) fn0) (v (form) a1))))))))) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (nform) Z) fn1) (a (c (fun (form) (nform)) ||) (v (form) a)))) (a (a (v (fun (form) (fun Z Z)) ||') (v (form) a)) (a (v (fun (form) Z) fn0) (v (form) a))))))))))))))))))))))))))))))))))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 155505685350029993
  library_tag: "c-fDL.ml"
  pretty_printed: "|- !pp' nn' pAtom' **' <>' nAtom' \.' /.' ||'. ?fn0 fn1 fn2.     (!a. fn0 (pp a) = pp' a (fn2 a)) /\     (!a. fn0 (nn a) = nn' a (fn1 a)) /\     (!a. fn2 (pAtom a) = pAtom' a) /\     (!a0 a1. fn2 (a0 ** a1) = **' a0 a1 (fn0 a0) (fn0 a1)) /\     (!a. fn2 (<>a) = <>' a (fn0 a)) /\     (!a. fn1 (nAtom a) = nAtom' a) /\     (!a0 a1. fn1 (a0 \. a1) = \.' a0 a1 (fn0 a0) (fn0 a1)) /\     (!a0 a1. fn1 (a0 /. a1) = /.' a0 a1 (fn0 a0) (fn0 a1)) /\     (!a. fn1 (||a) = ||' a (fn0 a))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 155505685350029993
}

theorems {
  conclusion:  "(a (c (fun (fun (fun (strF) (bool)) (bool)) (bool)) !) (l (v (fun (strF) (bool)) P0) (a (c (fun (fun (fun (strG) (bool)) (bool)) (bool)) !) (l (v (fun (strG) (bool)) P1) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (v (fun (strF) (bool)) P0) (a (c (fun (form) (strF)) ff) (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (strF) (bool)) P0) (v (strF) a))) (a (v (fun (strF) (bool)) P0) (a (c (fun (strF) (strF)) <>^) (v (strF) a))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a0) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a1) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (strF) (bool)) P0) (v (strF) a0))) (a (v (fun (strF) (bool)) P0) (v (strF) a1)))) (a (v (fun (strF) (bool)) P0) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) a0)) (v (strF) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (v (fun (strF) (bool)) P0) (a (c (fun (form) (strF)) focf) (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (v (fun (strG) (bool)) P1) (a (c (fun (form) (strG)) gg) (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) a) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (strG) (bool)) P1) (v (strG) a))) (a (v (fun (strG) (bool)) P1) (a (c (fun (strG) (strG)) ||^) (v (strG) a))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) a0) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a1) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (strG) (bool)) P1) (v (strG) a0))) (a (v (fun (strF) (bool)) P0) (v (strF) a1)))) (a (v (fun (strG) (bool)) P1) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) a0)) (v (strF) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a0) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) a1) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (strF) (bool)) P0) (v (strF) a0))) (a (v (fun (strG) (bool)) P1) (v (strG) a1)))) (a (v (fun (strG) (bool)) P1) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) a0)) (v (strG) a1))))))))) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (v (fun (strG) (bool)) P1) (a (c (fun (form) (strG)) focg) (v (form) a)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) x0) (a (v (fun (strF) (bool)) P0) (v (strF) x0))))) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) x1) (a (v (fun (strG) (bool)) P1) (v (strG) x1))))))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 1999787873279410053
  library_tag: "c-fDL.ml"
  pretty_printed: "|- !P0 P1. (!a. P0 (ff a)) /\ (!a. P0 a ==> P0 (<>^a)) /\ (!a0 a1. P0 a0 /\ P0 a1 ==> P0 (a0 **^ a1)) /\ (!a. P0 (focf a)) /\ (!a. P1 (gg a)) /\ (!a. P1 a ==> P1 (||^a)) /\ (!a0 a1. P1 a0 /\ P0 a1 ==> P1 (a0 /.^ a1)) /\ (!a0 a1. P0 a0 /\ P1 a1 ==> P1 (a0 \.^ a1)) /\ (!a. P1 (focg a)) ==> (!x0. P0 x0) /\ (!x1. P1 x1)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 1999787873279410053
}

theorems {
  conclusion:  "(a (c (fun (fun (fun (form) Z) (bool)) (bool)) !) (l (v (fun (form) Z) ff') (a (c (fun (fun (fun (strF) (fun Z Z)) (bool)) (bool)) !) (l (v (fun (strF) (fun Z Z)) <>^') (a (c (fun (fun (fun (strF) (fun (strF) (fun Z (fun Z Z)))) (bool)) (bool)) !) (l (v (fun (strF) (fun (strF) (fun Z (fun Z Z)))) **^') (a (c (fun (fun (fun (form) Z) (bool)) (bool)) !) (l (v (fun (form) Z) focf') (a (c (fun (fun (fun (form) Z) (bool)) (bool)) !) (l (v (fun (form) Z) gg') (a (c (fun (fun (fun (strG) (fun Z Z)) (bool)) (bool)) !) (l (v (fun (strG) (fun Z Z)) ||^') (a (c (fun (fun (fun (strG) (fun (strF) (fun Z (fun Z Z)))) (bool)) (bool)) !) (l (v (fun (strG) (fun (strF) (fun Z (fun Z Z)))) /.^') (a (c (fun (fun (fun (strF) (fun (strG) (fun Z (fun Z Z)))) (bool)) (bool)) !) (l (v (fun (strF) (fun (strG) (fun Z (fun Z Z)))) \\.^') (a (c (fun (fun (fun (form) Z) (bool)) (bool)) !) (l (v (fun (form) Z) focg') (a (c (fun (fun (fun (strF) Z) (bool)) (bool)) ?) (l (v (fun (strF) Z) fn0) (a (c (fun (fun (fun (strG) Z) (bool)) (bool)) ?) (l (v (fun (strG) Z) fn1) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (strF) Z) fn0) (a (c (fun (form) (strF)) ff) (v (form) a)))) (a (v (fun (form) Z) ff') (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (strF) Z) fn0) (a (c (fun (strF) (strF)) <>^) (v (strF) a)))) (a (a (v (fun (strF) (fun Z Z)) <>^') (v (strF) a)) (a (v (fun (strF) Z) fn0) (v (strF) a))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a0) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a1) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (strF) Z) fn0) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) a0)) (v (strF) a1)))) (a (a (a (a (v (fun (strF) (fun (strF) (fun Z (fun Z Z)))) **^') (v (strF) a0)) (v (strF) a1)) (a (v (fun (strF) Z) fn0) (v (strF) a0))) (a (v (fun (strF) Z) fn0) (v (strF) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (strF) Z) fn0) (a (c (fun (form) (strF)) focf) (v (form) a)))) (a (v (fun (form) Z) focf') (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (strG) Z) fn1) (a (c (fun (form) (strG)) gg) (v (form) a)))) (a (v (fun (form) Z) gg') (v (form) a)))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (strG) Z) fn1) (a (c (fun (strG) (strG)) ||^) (v (strG) a)))) (a (a (v (fun (strG) (fun Z Z)) ||^') (v (strG) a)) (a (v (fun (strG) Z) fn1) (v (strG) a))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) a0) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a1) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (strG) Z) fn1) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) a0)) (v (strF) a1)))) (a (a (a (a (v (fun (strG) (fun (strF) (fun Z (fun Z Z)))) /.^') (v (strG) a0)) (v (strF) a1)) (a (v (fun (strG) Z) fn1) (v (strG) a0))) (a (v (fun (strF) Z) fn0) (v (strF) a1))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a0) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) a1) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (strG) Z) fn1) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) a0)) (v (strG) a1)))) (a (a (a (a (v (fun (strF) (fun (strG) (fun Z (fun Z Z)))) \\.^') (v (strF) a0)) (v (strG) a1)) (a (v (fun (strF) Z) fn0) (v (strF) a0))) (a (v (fun (strG) Z) fn1) (v (strG) a1))))))))) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) a) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (strG) Z) fn1) (a (c (fun (form) (strG)) focg) (v (form) a)))) (a (v (fun (form) Z) focg') (v (form) a)))))))))))))))))))))))))))))))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 1700243215069139547
  library_tag: "c-fDL.ml"
  pretty_printed: "|- !ff' <>^' **^' focf' gg' ||^' /.^' \.^' focg'. ?fn0 fn1. (!a. fn0 (ff a) = ff' a) /\ (!a. fn0 (<>^a) = <>^' a (fn0 a)) /\ (!a0 a1. fn0 (a0 **^ a1) = **^' a0 a1 (fn0 a0) (fn0 a1)) /\ (!a. fn0 (focf a) = focf' a) /\ (!a. fn1 (gg a) = gg' a) /\ (!a. fn1 (||^a) = ||^' a (fn1 a)) /\ (!a0 a1. fn1 (a0 /.^ a1) = /.^' a0 a1 (fn1 a0) (fn0 a1)) /\ (!a0 a1. fn1 (a0 \.^ a1) = \.^' a0 a1 (fn0 a0) (fn1 a1)) /\ (!a. fn1 (focg a) = focg' a)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 1700243215069139547
}

theorems {
  conclusion:  "(a (c (fun (fun (fun (seq) (bool)) (bool)) (bool)) !) (l (v (fun (seq) (bool)) P) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a0) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) a1) (a (v (fun (seq) (bool)) P) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) a0)) (v (strG) a1)))))))) (a (c (fun (fun (seq) (bool)) (bool)) !) (l (v (seq) x) (a (v (fun (seq) (bool)) P) (v (seq) x)))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 897936064383853474 
  library_tag: "c-fDL.ml"
  pretty_printed: "|- !P. (!a0 a1. P (a0 --> a1)) ==> (!x. P x)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 897936064383853474
}

theorems {
  conclusion:  "(a (c (fun (fun (fun (strF) (fun (strG) Z)) (bool)) (bool)) !) (l (v (fun (strF) (fun (strG) Z)) -->') (a (c (fun (fun (fun (seq) Z) (bool)) (bool)) ?) (l (v (fun (seq) Z) fn) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) a0) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) a1) (a (a (c (fun Z (fun Z (bool))) =) (a (v (fun (seq) Z) fn) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) a0)) (v (strG) a1)))) (a (a (v (fun (strF) (fun (strG) Z)) -->') (v (strF) a0)) (v (strG) a1)))))))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 3597076660160509256 
  library_tag: "c-fDL.ml"
  pretty_printed: "|- !-->'. ?fn. !a0 a1. fn (a0 --> a1) = -->' a0 a1"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 3597076660160509256
}










theorems {
  conclusion:  "(a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (list (char)) (bool)) (bool)) !) (l (v (list (char)) p) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (list (char)) (bool)) (bool)) !) (l (v (list (char)) n) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (pform) (bool)) (bool)) !) (l (v (pform) A) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (v (pform) A)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (pform) (form)) pp) (v (pform) A))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (c (fun (fun (nform) (bool)) (bool)) !) (l (v (nform) B) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (c (fun (fun (pform) (bool)) (bool)) !) (l (v (pform) A) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (nform) (bool)) (bool)) !) (l (v (nform) B) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (v (nform) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (nform) (form)) nn) (v (nform) B))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (v (form) A))) (v (strG) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (v (strG) Y))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Z) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) W) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) Y)) (a (c (fun (strF) (strF)) <>^) (v (strF) Z))))) (v (strG) W)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (strF) (strF)) <>^) (v (strF) Z)))) (v (strG) W))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Z) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) W) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strF) Z))) (v (strG) W)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Z))) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strG) W))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B))))) (v (strG) Y))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (c (fun (form) (strG)) focg) (v (form) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B))))) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Y)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strG)) gg) (v (form) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) B)) (v (form) A))))) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Y)) (v (strF) X)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (a (c (fun (form) (strG)) gg) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (a (c (fun (form) (strF)) ff) (v (form) A)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A))))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (v (strF) X))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) A))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A))))) (a (c (fun (strG) (strG)) ||^) (v (strG) Y)))))))))) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (strG) (strG)) ||^) (a (c (fun (form) (strG)) gg) (v (form) A)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A)))))))))))))))))))))))))))))))))"
  tag: DEFINITION
  fingerprint: 1731490600655541338
 definition {
    definition_type: "INDUCTIVE"
    definition_term: "(a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (list (char)) (bool)) (bool)) !) (l (v (list (char)) p) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (list (char)) (bool)) (bool)) !) (l (v (list (char)) n) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (pform) (bool)) (bool)) !) (l (v (pform) A) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (v (pform) A)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (pform) (form)) pp) (v (pform) A))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (c (fun (fun (nform) (bool)) (bool)) !) (l (v (nform) B) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (c (fun (fun (pform) (bool)) (bool)) !) (l (v (pform) A) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (nform) (bool)) (bool)) !) (l (v (nform) B) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (v (nform) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (nform) (form)) nn) (v (nform) B))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (v (form) A))) (v (strG) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (v (strG) Y))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Z) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) W) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) Y)) (a (c (fun (strF) (strF)) <>^) (v (strF) Z))))) (v (strG) W)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (strF) (strF)) <>^) (v (strF) Z)))) (v (strG) W))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Z) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) W) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strF) Z))) (v (strG) W)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Z))) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strG) W))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B))))) (v (strG) Y))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (c (fun (form) (strG)) focg) (v (form) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B))))) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Y)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strG)) gg) (v (form) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) B)) (v (form) A))))) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Y)) (v (strF) X)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (a (c (fun (form) (strG)) gg) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (a (c (fun (form) (strF)) ff) (v (form) A)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A))))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (v (strF) X))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) A))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A))))) (a (c (fun (strG) (strG)) ||^) (v (strG) Y)))))))))) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (strG) (strG)) ||^) (a (c (fun (form) (strG)) gg) (v (form) A)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A)))))))))))))))))))))))))))))))))"
    constants: "|--"
  }    
  library_tag: "c-fDL.ml"
  pretty_printed: "|- (!p. |--(ff (pp (pAtom p)) --> focg (pp (pAtom p)))) /\ (!n. |--(focf (nn (nAtom n)) --> gg (nn (nAtom n)))) /\ (!X A. |--(X --> focg (pp A)) ==> |--(X --> gg (pp A))) /\ (!Y B. |--(focf (nn B) --> Y) ==> |--(ff (nn B) --> Y)) /\ (!Y A. |--(ff (pp A) --> Y) ==> |--(focf (pp A) --> Y)) /\ (!X B. |--(X --> gg (nn B)) ==> |--(X --> focg (nn B))) /\ (!X Y A. |--(X --> gg A) /\ |--(ff A --> Y) ==> |--(X --> Y)) /\ (!X Y Z. |--(Y --> X \.^ Z) ==> |--(X **^ Y --> Z)) /\ (!X Y Z. |--(X **^ Y --> Z) ==> |--(Y --> X \.^ Z)) /\ (!X Y Z. |--(X --> Z /.^ Y) ==> |--(X **^ Y --> Z)) /\ (!X Y Z. |--(X **^ Y --> Z) ==> |--(X --> Z /.^ Y)) /\ (!X Y Z W.      |--(X **^ Y **^ <>^Z --> W) ==> |--((X **^ Y) **^ <>^Z --> W)) /\ (!X Y Z W.      |--((X **^ <>^Y) **^ Z --> W) ==> |--((X **^ Z) **^ <>^Y --> W)) /\ (!A B Y. |--(ff A **^ ff B --> Y) ==> |--(ff (pp (A ** B)) --> Y)) /\ (!A B X Y.      |--(X --> focg A) /\ |--(Y --> focg B)      ==> |--(X **^ Y --> focg (pp (A ** B)))) /\ (!A B X Y.      |--(X --> focg A) /\ |--(focf B --> Y)      ==> |--(focf (nn (A \. B)) --> X \.^ Y)) /\ (!A B X. |--(X --> ff A \.^ gg B) ==> |--(X --> gg (nn (A \. B)))) /\ (!A B X Y.      |--(X --> focg A) /\ |--(focf B --> Y)      ==> |--(focf (nn (B /. A)) --> Y /.^ X)) /\ (!A B X. |--(X --> gg A /.^ ff B) ==> |--(X --> gg (nn (A /. B)))) /\ (!A Y. |--(<>^ff A --> Y) ==> |--(ff (pp (<>A)) --> Y)) /\ (!A X. |--(X --> focg A) ==> |--(<>^X --> focg (pp (<>A)))) /\ (!A Y. |--(focf A --> Y) ==> |--(focf (nn (||A)) --> ||^Y)) /\ (!A X. |--(X --> ||^gg A) ==> |--(X --> gg (nn (||A))))"
}

theorems {
  conclusion:  "(a (c (fun (fun (fun (seq) (bool)) (bool)) (bool)) !) (l (v (fun (seq) (bool)) |--') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (list (char)) (bool)) (bool)) !) (l (v (list (char)) p) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (list (char)) (bool)) (bool)) !) (l (v (list (char)) n) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (pform) (bool)) (bool)) !) (l (v (pform) A) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (v (pform) A)))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (pform) (form)) pp) (v (pform) A))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (c (fun (fun (nform) (bool)) (bool)) !) (l (v (nform) B) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (c (fun (fun (pform) (bool)) (bool)) !) (l (v (pform) A) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (nform) (bool)) (bool)) !) (l (v (nform) B) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (v (nform) B)))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (nform) (form)) nn) (v (nform) B))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (v (form) A))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (v (form) A))) (v (strG) Y))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (v (strG) Y))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Z) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) W) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) Y)) (a (c (fun (strF) (strF)) <>^) (v (strF) Z))))) (v (strG) W)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (strF) (strF)) <>^) (v (strF) Z)))) (v (strG) W))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Z) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) W) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strF) Z))) (v (strG) W)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Z))) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strG) W))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B)))) (v (strG) Y)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B))))) (v (strG) Y))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (c (fun (form) (strG)) focg) (v (form) B)))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B))))) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Y)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strG)) gg) (v (form) B)))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) B)) (v (form) A))))) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Y)) (v (strF) X)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (a (c (fun (form) (strG)) gg) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B)))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (a (c (fun (form) (strF)) ff) (v (form) A)))) (v (strG) Y)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A))))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (v (strF) X))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) A))) (v (strG) Y)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A))))) (a (c (fun (strG) (strG)) ||^) (v (strG) Y)))))))))) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (strG) (strG)) ||^) (a (c (fun (form) (strG)) gg) (v (form) A)))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A)))))))))))))))))))))))))))))))))) (a (c (fun (fun (seq) (bool)) (bool)) !) (l (v (seq) a) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (v (seq) a))) (a (v (fun (seq) (bool)) |--') (v (seq) a))))))))"
  tag: DEFINITION
  fingerprint: 542832381281218950
  library_tag: "c-fDL.ml"
  definition {
    definition_type: "INDUCTIVE"
    definition_term: "(a (c (fun (fun (fun (seq) (bool)) (bool)) (bool)) !) (l (v (fun (seq) (bool)) |--') (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (list (char)) (bool)) (bool)) !) (l (v (list (char)) p) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (list (char)) (bool)) (bool)) !) (l (v (list (char)) n) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (pform) (bool)) (bool)) !) (l (v (pform) A) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (v (pform) A)))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (pform) (form)) pp) (v (pform) A))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (c (fun (fun (nform) (bool)) (bool)) !) (l (v (nform) B) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (c (fun (fun (pform) (bool)) (bool)) !) (l (v (pform) A) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (nform) (bool)) (bool)) !) (l (v (nform) B) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (v (nform) B)))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (nform) (form)) nn) (v (nform) B))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (v (form) A))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (v (form) A))) (v (strG) Y))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (v (strG) Y))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Z) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) W) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) Y)) (a (c (fun (strF) (strF)) <>^) (v (strF) Z))))) (v (strG) W)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (strF) (strF)) <>^) (v (strF) Z)))) (v (strG) W))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Z) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) W) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strF) Z))) (v (strG) W)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Z))) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strG) W))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B)))) (v (strG) Y)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B))))) (v (strG) Y))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (c (fun (form) (strG)) focg) (v (form) B)))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B))))) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Y)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strG)) gg) (v (form) B)))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) B)) (v (form) A))))) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Y)) (v (strF) X)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (a (c (fun (form) (strG)) gg) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B)))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (a (c (fun (form) (strF)) ff) (v (form) A)))) (v (strG) Y)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A))))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (v (strF) X))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) A))) (v (strG) Y)))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A))))) (a (c (fun (strG) (strG)) ||^) (v (strG) Y)))))))))) (a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strF) (bool)) (bool)) !) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (strG) (strG)) ||^) (a (c (fun (form) (strG)) gg) (v (form) A)))))) (a (v (fun (seq) (bool)) |--') (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A)))))))))))))))))))))))))))))))))) (a (c (fun (fun (seq) (bool)) (bool)) !) (l (v (seq) a) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (v (seq) a))) (a (v (fun (seq) (bool)) |--') (v (seq) a))))))))"
    constants: "|--"
  }   
  pretty_printed: "|- !|--'. (!p. |--' (ff (pp (pAtom p)) --> focg (pp (pAtom p)))) /\ (!n. |--' (focf (nn (nAtom n)) --> gg (nn (nAtom n)))) /\ (!X A. |--' (X --> focg (pp A)) ==> |--' (X --> gg (pp A))) /\ (!Y B. |--' (focf (nn B) --> Y) ==> |--' (ff (nn B) --> Y)) /\ (!Y A. |--' (ff (pp A) --> Y) ==> |--' (focf (pp A) --> Y)) /\ (!X B. |--' (X --> gg (nn B)) ==> |--' (X --> focg (nn B))) /\ (!X Y A.      |--' (X --> gg A) /\ |--' (ff A --> Y) ==> |--' (X --> Y)) /\ (!X Y Z. |--' (Y --> X \.^ Z) ==> |--' (X **^ Y --> Z)) /\ (!X Y Z. |--' (X **^ Y --> Z) ==> |--' (Y --> X \.^ Z)) /\ (!X Y Z. |--' (X --> Z /.^ Y) ==> |--' (X **^ Y --> Z)) /\ (!X Y Z. |--' (X **^ Y --> Z) ==> |--' (X --> Z /.^ Y)) /\ (!X Y Z W.      |--' (X **^ Y **^ <>^Z --> W)      ==> |--' ((X **^ Y) **^ <>^Z --> W)) /\ (!X Y Z W.      |--' ((X **^ <>^Y) **^ Z --> W)      ==> |--' ((X **^ Z) **^ <>^Y --> W)) /\ (!A B Y.      |--' (ff A **^ ff B --> Y) ==> |--' (ff (pp (A ** B)) --> Y)) /\ (!A B X Y.      |--' (X --> focg A) /\ |--' (Y --> focg B)      ==> |--' (X **^ Y --> focg (pp (A ** B)))) /\ (!A B X Y.      |--' (X --> focg A) /\ |--' (focf B --> Y)      ==> |--' (focf (nn (A \. B)) --> X \.^ Y)) /\ (!A B X.      |--' (X --> ff A \.^ gg B) ==> |--' (X --> gg (nn (A \. B)))) /\ (!A B X Y.      |--' (X --> focg A) /\ |--' (focf B --> Y)      ==> |--' (focf (nn (B /. A)) --> Y /.^ X)) /\ (!A B X.      |--' (X --> gg A /.^ ff B) ==> |--' (X --> gg (nn (A /. B)))) /\ (!A Y. |--' (<>^ff A --> Y) ==> |--' (ff (pp (<>A)) --> Y)) /\ (!A X. |--' (X --> focg A) ==> |--' (<>^X --> focg (pp (<>A)))) /\ (!A Y. |--' (focf A --> Y) ==> |--' (focf (nn (||A)) --> ||^Y)) /\ (!A X. |--' (X --> ||^gg A) ==> |--' (X --> gg (nn (||A)))) ==> (!a. |--a ==> |--' a)"
}

theorems {
  conclusion:  "(a (c (fun (fun (seq) (bool)) (bool)) !) (l (v (seq) a) (a (a (c (fun (bool) (fun (bool) (bool))) =) (a (c (fun (seq) (bool)) |--) (v (seq) a))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) p) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) n) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (pform) (bool)) (bool)) ?) (l (v (pform) A) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (pform) (form)) pp) (v (pform) A)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (v (pform) A))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (c (fun (fun (nform) (bool)) (bool)) ?) (l (v (nform) B) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (c (fun (fun (pform) (bool)) (bool)) ?) (l (v (pform) A) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (nform) (bool)) (bool)) ?) (l (v (nform) B) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (nform) (form)) nn) (v (nform) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (v (nform) B))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (v (strG) Y)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (v (form) A))) (v (strG) Y)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Z) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) W) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (strF) (strF)) <>^) (v (strF) Z)))) (v (strG) W)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) Y)) (a (c (fun (strF) (strF)) <>^) (v (strF) Z))))) (v (strG) W))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Z) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) W) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Z))) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strG) W)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strF) Z))) (v (strG) W))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) B) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B))))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B)))) (v (strG) Y))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (c (fun (form) (strG)) focg) (v (form) B))))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B))))) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Y))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B))))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strG)) gg) (v (form) B))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) B)) (v (form) A))))) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Y)) (v (strF) X))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B))))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (a (c (fun (form) (strG)) gg) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A))))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (a (c (fun (form) (strF)) ff) (v (form) A)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (v (strF) X))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A))))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A)))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A))))) (a (c (fun (strG) (strG)) ||^) (v (strG) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) A))) (v (strG) Y))))))))) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A))))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (strG) (strG)) ||^) (a (c (fun (form) (strG)) gg) (v (form) A)))))))))))))))))))))))))))))))))))"
  tag: DEFINITION
  fingerprint: 3250145132325267327
  definition {
    definition_type: "INDUCTIVE"
    definition_term: "(a (c (fun (fun (seq) (bool)) (bool)) !) (l (v (seq) a) (a (a (c (fun (bool) (fun (bool) (bool))) =) (a (c (fun (seq) (bool)) |--) (v (seq) a))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) p) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (list (char)) (bool)) (bool)) ?) (l (v (list (char)) n) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (pform) (bool)) (bool)) ?) (l (v (pform) A) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (pform) (form)) pp) (v (pform) A)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (v (pform) A))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (c (fun (fun (nform) (bool)) (bool)) ?) (l (v (nform) B) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (c (fun (fun (pform) (bool)) (bool)) ?) (l (v (pform) A) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (nform) (bool)) (bool)) ?) (l (v (nform) B) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (nform) (form)) nn) (v (nform) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (v (nform) B))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (v (strG) Y)))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (v (form) A))) (v (strG) Y)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y)))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Z) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Z) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) W) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (strF) (strF)) <>^) (v (strF) Z)))) (v (strG) W)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) Y)) (a (c (fun (strF) (strF)) <>^) (v (strF) Z))))) (v (strG) W))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Z) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) W) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Z))) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strG) W)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strF) Z))) (v (strG) W))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) B) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B))))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B)))) (v (strG) Y))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) Y) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B))))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (c (fun (form) (strG)) focg) (v (form) B))))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B))))) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Y))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B))))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strG)) gg) (v (form) B))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) B)) (v (form) A))))) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Y)) (v (strF) X))))) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y)))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) B) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B))))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (a (c (fun (form) (strG)) gg) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B))))))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A))))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (a (c (fun (form) (strF)) ff) (v (form) A)))) (v (strG) Y))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (v (strF) X))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A))))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A)))))))))) (a (a (c (fun (bool) (fun (bool) (bool))) \\/) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) ?) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A))))) (a (c (fun (strG) (strG)) ||^) (v (strG) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) A))) (v (strG) Y))))))))) (a (c (fun (fun (form) (bool)) (bool)) ?) (l (v (form) A) (a (c (fun (fun (strF) (bool)) (bool)) ?) (l (v (strF) X) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (a (c (fun (seq) (fun (seq) (bool))) =) (v (seq) a)) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A))))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (strG) (strG)) ||^) (a (c (fun (form) (strG)) gg) (v (form) A)))))))))))))))))))))))))))))))))))"
    constants: "|--"
  }  
  library_tag: "c-fDL.ml"
  pretty_printed: "|- !a. |--a <=> (?p. a = (ff (pp (pAtom p)) --> focg (pp (pAtom p)))) \/ (?n. a = (focf (nn (nAtom n)) --> gg (nn (nAtom n)))) \/ (?X A. a = (X --> gg (pp A)) /\ |--(X --> focg (pp A))) \/ (?Y B. a = (ff (nn B) --> Y) /\ |--(focf (nn B) --> Y)) \/ (?Y A. a = (focf (pp A) --> Y) /\ |--(ff (pp A) --> Y)) \/ (?X B. a = (X --> focg (nn B)) /\ |--(X --> gg (nn B))) \/ (?X Y A. a = (X --> Y) /\ |--(X --> gg A) /\ |--(ff A --> Y)) \/ (?X Y Z. a = (X **^ Y --> Z) /\ |--(Y --> X \.^ Z)) \/ (?X Y Z. a = (Y --> X \.^ Z) /\ |--(X **^ Y --> Z)) \/ (?X Y Z. a = (X **^ Y --> Z) /\ |--(X --> Z /.^ Y)) \/ (?X Y Z. a = (X --> Z /.^ Y) /\ |--(X **^ Y --> Z)) \/ (?X Y Z W.      a = ((X **^ Y) **^ <>^Z --> W) /\ |--(X **^ Y **^ <>^Z --> W)) \/ (?X Y Z W.      a = ((X **^ Z) **^ <>^Y --> W) /\ |--((X **^ <>^Y) **^ Z --> W)) \/ (?A B Y. a = (ff (pp (A ** B)) --> Y) /\ |--(ff A **^ ff B --> Y)) \/ (?A B X Y.      a = (X **^ Y --> focg (pp (A ** B))) /\      |--(X --> focg A) /\      |--(Y --> focg B)) \/ (?A B X Y.      a = (focf (nn (A \. B)) --> X \.^ Y) /\      |--(X --> focg A) /\      |--(focf B --> Y)) \/ (?A B X. a = (X --> gg (nn (A \. B))) /\ |--(X --> ff A \.^ gg B)) \/ (?A B X Y.      a = (focf (nn (B /. A)) --> Y /.^ X) /\      |--(X --> focg A) /\      |--(focf B --> Y)) \/ (?A B X. a = (X --> gg (nn (A /. B))) /\ |--(X --> gg A /.^ ff B)) \/ (?A Y. a = (ff (pp (<>A)) --> Y) /\ |--(<>^ff A --> Y)) \/ (?A X. a = (<>^X --> focg (pp (<>A))) /\ |--(X --> focg A)) \/ (?A Y. a = (focf (nn (||A)) --> ||^Y) /\ |--(focf A --> Y)) \/ (?A X. a = (X --> gg (nn (||A))) /\ |--(X --> ||^gg A))|- !a. |--a <=> (?p. a = (ff (pp (pAtom p)) --> focg (pp (pAtom p)))) \/ (?n. a = (focf (nn (nAtom n)) --> gg (nn (nAtom n)))) \/ (?X A. a = (X --> gg (pp A)) /\ |--(X --> focg (pp A))) \/ (?Y B. a = (ff (nn B) --> Y) /\ |--(focf (nn B) --> Y)) \/ (?Y A. a = (focf (pp A) --> Y) /\ |--(ff (pp A) --> Y)) \/ (?X B. a = (X --> focg (nn B)) /\ |--(X --> gg (nn B))) \/ (?X Y A. a = (X --> Y) /\ |--(X --> gg A) /\ |--(ff A --> Y)) \/ (?X Y Z. a = (X **^ Y --> Z) /\ |--(Y --> X \.^ Z)) \/ (?X Y Z. a = (Y --> X \.^ Z) /\ |--(X **^ Y --> Z)) \/ (?X Y Z. a = (X **^ Y --> Z) /\ |--(X --> Z /.^ Y)) \/ (?X Y Z. a = (X --> Z /.^ Y) /\ |--(X **^ Y --> Z)) \/ (?X Y Z W.      a = ((X **^ Y) **^ <>^Z --> W) /\ |--(X **^ Y **^ <>^Z --> W)) \/ (?X Y Z W.      a = ((X **^ Z) **^ <>^Y --> W) /\ |--((X **^ <>^Y) **^ Z --> W)) \/ (?A B Y. a = (ff (pp (A ** B)) --> Y) /\ |--(ff A **^ ff B --> Y)) \/ (?A B X Y.      a = (X **^ Y --> focg (pp (A ** B))) /\      |--(X --> focg A) /\      |--(Y --> focg B)) \/ (?A B X Y.      a = (focf (nn (A \. B)) --> X \.^ Y) /\      |--(X --> focg A) /\      |--(focf B --> Y)) \/ (?A B X. a = (X --> gg (nn (A \. B))) /\ |--(X --> ff A \.^ gg B)) \/ (?A B X Y.      a = (focf (nn (B /. A)) --> Y /.^ X) /\      |--(X --> focg A) /\      |--(focf B --> Y)) \/ (?A B X. a = (X --> gg (nn (A /. B))) /\ |--(X --> gg A /.^ ff B)) \/ (?A Y. a = (ff (pp (<>A)) --> Y) /\ |--(<>^ff A --> Y)) \/ (?A X. a = (<>^X --> focg (pp (<>A))) /\ |--(X --> focg A)) \/ (?A Y. a = (focf (nn (||A)) --> ||^Y) /\ |--(focf A --> Y)) \/ (?A X. a = (X --> gg (nn (||A))) /\ |--(X --> ||^gg A))"
}










theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (list (char)) (pform)) pAtom) (v (list (char)) p))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 1007035279306008906 
  library_tag: "c-fDL.ml"
  pretty_printed: "|-- (ff (pp(pAtom p)) --> focg (pp(pAtom p)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 1007035279306008906
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (list (char)) (nform)) nAtom) (v (list (char)) n))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 1187715231784222460 
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(focf (nn(nAtom n)) --> gg (nn(nAtom n)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 1187715231784222460
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (v (pform) A)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (pform) (form)) pp) (v (pform) A))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 3916849617694832802 
  library_tag: "c-fDL.ml"
  pretty_printed: "|-- (X --> focg (pp A)) ==> |-- (X --> gg (pp A))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 3916849617694832802
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (v (nform) B)))) (v (strG) Y))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 2729922715878395835
  library_tag: "c-fDL.ml"
  pretty_printed: "|-- (focf (nn B) --> Y) ==> |-- ((ff (nn B)) --> Y)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 2729922715878395835
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (pform) (form)) pp) (v (pform) A)))) (v (strG) Y))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 342805088893452418
  library_tag: "c-fDL.ml"
  pretty_printed: "|-- ((ff (pp A)) --> Y) ==> |-- (focf (pp A) --> Y)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 342805088893452418
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (v (nform) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (a (c (fun (nform) (form)) nn) (v (nform) B))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 179620025354027039
  library_tag: "c-fDL.ml"
  pretty_printed: "|-- (X --> gg (nn B)) ==> |-- (X --> focg (nn B))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 179620025354027039
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (v (form) A))) (v (strG) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (v (strG) Y))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 2512923059779155992
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(X --> gg A) /\ |--(ff A --> Y) ==> |--(X --> Y)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 2512923059779155992
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 4232277928518346106
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(Y --> X \.^ Z) ==> |--(X **^ Y --> Z)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 4232277928518346106
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Z)))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 3382036967057169017
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(X **^ Y --> Z) ==> |--(Y --> X \.^ Z)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 3382036967057169017
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 80357916665140923
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(X --> Z /.^ Y) ==> |--(X **^ Y --> Z)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 80357916665140923
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (v (strG) Z)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Z)) (v (strF) Y)))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 4354276773536781758
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(X **^ Y --> Z) ==> |--(X --> Z /.^ Y)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 4354276773536781758
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) Y)) (a (c (fun (strF) (strF)) <>^) (v (strF) Z))))) (v (strG) W)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (strF) (strF)) <>^) (v (strF) Z)))) (v (strG) W))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 3122908811776831354
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(X **^ (Y **^ <>^Z) --> W) ==> |--((X **^ Y) **^ <>^Z --> W)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 3122908811776831354
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strF) Z))) (v (strG) W)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Z))) (a (c (fun (strF) (strF)) <>^) (v (strF) Y)))) (v (strG) W))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 2681640057750126103
  library_tag: "c-fDL.ml"
  pretty_printed: "|--((X **^ <>^Y) **^ Z --> W) ==> |--((X **^ Z) **^ <>^Y --> W)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 2681640057750126103
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B))))) (v (strG) Y))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 3786977292081973259
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff A **^ ff B --> Y) ==> |--(ff (pp(A ** B)) --> Y)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 3786977292081973259
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) Y)) (a (c (fun (form) (strG)) focg) (v (form) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (a (c (fun (strF) (fun (strF) (strF))) **^) (v (strF) X)) (v (strF) Y))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 1189472279349915874
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(X --> focg A) /\ |--(Y --> focg B) ==> |--(X **^ Y --> focg(pp(A ** B)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 1189472279349915874
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B))))) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (v (strF) X)) (v (strG) Y)))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 482601273770280345
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(X --> focg A) /\ |--(focf B --> Y) ==> |--(focf(nn(A \. B)) --> X \.^ Y)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 482601273770280345
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strF) (fun (strG) (strG))) \\.^) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strG)) gg) (v (form) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B)))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 1343266868598904740
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(X --> ff A \.^ gg B) ==> |--(X --> gg(nn(A \. B)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 1343266868598904740
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (a (c (fun (bool) (fun (bool) (bool))) /\\) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) B))) (v (strG) Y))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) B)) (v (form) A))))) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (v (strG) Y)) (v (strF) X)))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 568216404461289665
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(X --> focg A) /\ |--(focf B --> Y) ==> |--(focf(nn(B /. A)) --> Y /.^ X)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 568216404461289665
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (a (c (fun (strG) (fun (strF) (strG))) /.^) (a (c (fun (form) (strG)) gg) (v (form) A))) (a (c (fun (form) (strF)) ff) (v (form) B)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B)))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 4265750580742147688
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(X --> gg A /.^ ff B) ==> |--(X --> gg (nn(A /. B)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 4265750580742147688
}

theorems {
  conclusion: "(a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (fun (strG) (bool)) (bool)) !) (l (v (strG) Y) (a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (a (c (fun (form) (strF)) ff) (v (form) A)))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A))))) (v (strG) Y))))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "!A Y. |--(<>^ff A --> Y) ==> |--(ff (pp(<>A)) --> Y))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) focg) (v (form) A))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (strF) (strF)) <>^) (v (strF) X))) (a (c (fun (form) (strG)) focg) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A)))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(X --> focg A) ==> |--(<>^X --> focg (pp(<>A)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) A))) (v (strG) Y)))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A))))) (a (c (fun (strG) (strG)) ||^) (v (strG) Y)))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(focf A --> Y) ==> |--(focf (nn (||A)) --> ||^Y)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (a (c (fun (bool) (fun (bool) (bool))) ==>) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (strG) (strG)) ||^) (a (c (fun (form) (strG)) gg) (v (form) A)))))) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (v (strF) X)) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (c (fun (form) (nform)) ||) (v (form) A)))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(X --> ||^gg A) ==> |--(X --> gg (nn (||A)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}






theorems {
  conclusion: "(a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) focf) (v (form) A))) (a (c (fun (form) (strG)) gg) (v (form) A))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "(!A. |-- (focf A --> gg A))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (fun (form) (bool)) (bool)) !) (l (v (form) A) (a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (v (form) A))) (a (c (fun (form) (strG)) focg) (v (form) A))))))"
  tag: THEOREM
  training_split: TRAINING
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "(!A. |-- (ff A --> focg A))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}


























theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) X)) (v (form) Y)))) (v (form) Y))))) (a (c (fun (form) (strG)) gg) (v (form) X))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp ((nn (X /. Y)) ** Y)) --> gg X)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) Y)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) Y)) (v (form) X))))))) (a (c (fun (form) (strG)) gg) (v (form) X))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp (Y ** (nn (Y \. X)))) --> gg X)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (v (form) Y))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) X)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) Y)) (v (form) X))))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff Y --> gg ( nn ( X /. ( nn (Y \. X)))))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (v (form) Y))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) X)) (v (form) Y)))) (v (form) X))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff Y --> gg ( nn (( nn (X /. Y)) \. X)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) B)) (v (form) A)))))) (v (form) A))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) B)) (v (form) A))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (nn ( (nn ( A /. ( nn (B \. A)))) \. A)) --> gg (nn (B \. A)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) B)) (v (form) A))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) B)) (v (form) A)))))) (v (form) A))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (nn (B \. A)) --> gg (nn ( (nn ( A /. ( nn (B \. A)))) \. A)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B)))) (v (form) B)))) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) C))))))) (a (c (fun (form) (strG)) gg) (v (form) C))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp ((pp ((nn (A /. B)) ** B)) ** (nn (A \. C)))) --> gg C)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B)))) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B)))))) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B))))))))) (a (c (fun (form) (strG)) gg) (v (form) B))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp (A ** (pp ( (nn ((nn (A \. B)) /. (nn (A \. B)))) ** (nn (A \. B)))))) --> gg B)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (v (form) B)))) (v (form) A)))) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) C)))) (v (form) C))))))))) (a (c (fun (form) (strG)) gg) (v (form) B))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp (A ** (pp ((nn ((nn (A \. B)) /. A)) ** (pp ((nn (A /. C)) ** C)))))) --> gg B)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (v (form) A)))) (v (form) C)))))) (v (form) C))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (v (form) A)))) (v (form) C))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (nn ((nn (C /. (nn ( (nn (C /. A)) \. C)))) \. C)) --> gg (nn ((nn (C /. A)) \. C)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion:  "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (v (form) A)))) (v (form) C))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (v (form) A)))) (v (form) C)))))) (v (form) C))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (nn ((nn (C /. A)) \. C)) --> gg (nn ((nn (C /. (nn ( (nn (C /. A)) \. C)))) \. C)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))) (v (form) A))))) (a (c (fun (form) (strG)) gg) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))) (v (form) C)))) (v (form) C)))) (v (form) A))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp ((pp (A ** B)) ** A)) --> gg (pp ((nn ((pp ((pp (A ** B)) ** C)) /. C)) ** A)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))) (v (form) C))))))) (a (c (fun (form) (strG)) gg) (v (form) C))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (nn ((pp (A ** B)) \. (pp ((pp (A ** B)) ** C))))--> gg C)"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))) (v (form) C)))))) (v (form) C))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (v (form) B)))) (v (form) B))))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (nn ((nn ((pp (A ** B)) \. (pp ((pp (A ** B)) ** C)))) /. C)) --> gg (nn (C /. (pp ((nn (C /. B)) ** B)))))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))) (v (form) C)))))) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) C)) (v (form) A))))))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (v (form) C))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (nn ((nn ((pp (A ** B)) \. (pp ((pp (A ** B)) ** C)))) /. (nn (A /. (nn ( C\. A)))))) --> gg (nn (C /. C)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B)))) (v (form) C)))))) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) C)) (v (form) D)))) (v (form) A))))))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) D)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) C)) (v (form) D)))))) (v (form) D))))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (nn ((nn ((pp (A ** B)) \. (pp ((pp (A ** B)) ** C)))) /. (nn (A /. (nn ( (nn (C \. D))\. A)))))) --> gg (nn (C /. (nn ((nn (D /. (nn (C \. D)))) \. D)))))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) D)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) C)) (v (form) D)))))) (v (form) D))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) C)) (v (form) D)))) (v (form) A))))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (nn ((nn (D /. (nn (C \. D)))) \. D)) --> gg (nn (A /. (nn ( (nn (C \. D))\. A)))))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B))))))) (a (c (fun (form) (strG)) gg) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (v (form) A)))) (v (form) C)))) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B))))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp (A ** (nn (A /. B))))--> gg (pp (( nn (( nn (C /. A)) \. C)) ** (nn (A /. B)))))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) D)) (v (form) C))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) D)) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B)))) (v (form) B)))) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B)))) (v (form) B)))) (v (form) C))))))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (nn (D /. C)) --> gg (nn (D /. (pp ( (pp ((nn (A /. B)) ** B)) ** (nn ((pp ((nn (A /. B)) ** B)) \. C)))))))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B)))) (v (form) B)))) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B)))) (v (form) B)))) (v (form) C))))))) (a (c (fun (form) (strG)) gg) (v (form) C))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp ( (pp ((nn (A /. B)) ** B)) ** (nn ((pp ((nn (A /. B)) ** B)) \. C)))) --> gg (C))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) A)) (v (form) B)))) (v (form) B)))) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) A)) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) C))))))))) (a (c (fun (form) (strG)) gg) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) C))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp ((pp ((nn (A /. B)) ** B)) ** (nn (A \. (pp (<> C)))))) --> gg (pp (<> C)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) A)))))) (v (form) C))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) C)) (v (form) A)))) (v (form) C)))))))) (v (form) C))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (nn ((nn (C /. (pp (<> A)))) \. C)) --> gg (nn ((nn (C /. (pp (<> (nn ( (nn (C /. A)) \. C)))))) \. C)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) X)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) Y)) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) Z))))))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) X)) (v (form) Y)))) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) Z))))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp( X ** (nn ( Y /. (pp (<> Z)))))) --> gg (nn ((pp (X ** Y)) /. (pp (<>  Z)))))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion:  "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) X)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) Y)) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) Z))))))))))) (a (c (fun (form) (strG)) gg) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) X)) (v (form) Y)))) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) Z))))))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp (<> (pp( X ** (nn ( Y /. (pp (<> Z)))))))) --> gg (pp (<> (nn ((pp (X ** Y)) /. (pp (<>  Z)))))))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) X)) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) Y)))) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) Z))))))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) X)) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) Y)))))) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) Z))))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp( X ** (nn ( (pp (<>Y)) /. (pp (<> Z)))))) --> gg (nn ((pp (X ** (pp (<>Y)))) /. (pp (<>  Z)))))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) X)) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) Z)) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) Y))))))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) X)) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) Y)))))) (v (form) Z))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (nn (X /. (pp( Z ** (pp (<> Y)))))) --> gg (nn ((nn (X /. (pp (<> Y)))) /. Z)))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) Z)) (v (form) Y)))) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) Y)) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) X))))))))) (a (c (fun (form) (strG)) gg) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) /.) (v (form) Z)) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (v (form) X))))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp ((nn (Z /. Y)) ** ( nn (Y/. (pp (<> X)))))) --> gg ( nn (Z /. (pp (<> X)))))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

theorems {
  conclusion: "(a (c (fun (seq) (bool)) |--) (a (a (c (fun (strF) (fun (strG) (seq))) -->) (a (c (fun (form) (strF)) ff) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B))))))))))) (a (c (fun (form) (strG)) gg) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (a (c (fun (nform) (form)) nn) (a (a (c (fun (form) (fun (form) (nform))) \\.) (v (form) C)) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) C)) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (a (c (fun (pform) (form)) pp) (a (c (fun (form) (pform)) <>) (a (c (fun (pform) (form)) pp) (a (a (c (fun (form) (fun (form) (pform))) **) (v (form) A)) (v (form) B))))))))))))))))"
  tag: THEOREM
  training_split: VALIDATION
  fingerprint: 9999
  library_tag: "c-fDL.ml"
  pretty_printed: "|--(ff (pp (<> (pp (<> (pp (<> (pp (A ** B)))))))) --> gg (pp (<> (nn (C \. (pp (C ** (pp (<> (pp (<> (pp (A ** B)))))))))))))"
  proof_function: "TAC_PROOF"
  goal_fingerprint: 9999
}

